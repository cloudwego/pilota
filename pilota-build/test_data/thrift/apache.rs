pub mod apache {
    #![allow(warnings, clippy::all)]

    pub mod thrift {

        pub mod rs {

            pub mod test {

                /**
                 * Docstring!
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq, Copy)]
                #[repr(transparent)]
                pub struct Numberz(i32);

                impl Numberz {
                    pub const ONE: Self = Self(1);
                    pub const TWO: Self = Self(2);
                    pub const THREE: Self = Self(3);
                    pub const FIVE: Self = Self(5);
                    pub const SIX: Self = Self(6);
                    pub const EIGHT: Self = Self(8);

                    pub fn inner(&self) -> i32 {
                        self.0
                    }

                    pub fn to_string(&self) -> ::std::string::String {
                        match self {
                            Self(1) => ::std::string::String::from("ONE"),
                            Self(2) => ::std::string::String::from("TWO"),
                            Self(3) => ::std::string::String::from("THREE"),
                            Self(5) => ::std::string::String::from("FIVE"),
                            Self(6) => ::std::string::String::from("SIX"),
                            Self(8) => ::std::string::String::from("EIGHT"),
                            Self(val) => val.to_string(),
                        }
                    }

                    pub fn try_from_i32(value: i32) -> ::std::option::Option<Self> {
                        match value {
                            1 => Some(Self::ONE),
                            2 => Some(Self::TWO),
                            3 => Some(Self::THREE),
                            5 => Some(Self::FIVE),
                            6 => Some(Self::SIX),
                            8 => Some(Self::EIGHT),
                            _ => None,
                        }
                    }
                }

                impl ::std::convert::From<i32> for Numberz {
                    fn from(value: i32) -> Self {
                        Self(value)
                    }
                }

                impl ::std::convert::From<Numberz> for i32 {
                    fn from(value: Numberz) -> i32 {
                        value.0
                    }
                }

                impl ::pilota::thrift::Message for Numberz {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_i32(self.inner())?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let value = __protocol.read_i32()?;
                        ::std::result::Result::Ok(
                            ::std::convert::TryFrom::try_from(value).map_err(|err| {
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    format!("invalid enum value for Numberz, value: {}", value),
                                )
                            })?,
                        )
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let value = __protocol.read_i32().await?;
                            ::std::result::Result::Ok(
                                ::std::convert::TryFrom::try_from(value).map_err(|err| {
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        format!("invalid enum value for Numberz, value: {}", value),
                                    )
                                })?,
                            )
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.i32_len(self.inner())
                    }
                }

                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct LargeDeltas {
                    pub b1: ::std::option::Option<Bools>,

                    pub b10: ::std::option::Option<Bools>,

                    pub b100: ::std::option::Option<Bools>,

                    pub check_true: ::std::option::Option<bool>,

                    pub b1000: ::std::option::Option<Bools>,

                    pub check_false: ::std::option::Option<bool>,

                    pub vertwo2000: ::std::option::Option<VersioningTestV2>,

                    pub a_set2500: ::std::option::Option<::pilota::AHashSet<::pilota::FastStr>>,

                    pub vertwo3000: ::std::option::Option<VersioningTestV2>,

                    pub big_numbers: ::std::option::Option<::std::vec::Vec<i32>>,
                }
                impl ::pilota::thrift::Message for LargeDeltas {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "LargeDeltas",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.b1.as_ref() {
                            __protocol.write_struct_field(
                                1,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        if let Some(value) = self.b10.as_ref() {
                            __protocol.write_struct_field(
                                10,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        if let Some(value) = self.b100.as_ref() {
                            __protocol.write_struct_field(
                                100,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        if let Some(value) = self.check_true.as_ref() {
                            __protocol.write_bool_field(500, *value)?;
                        }
                        if let Some(value) = self.b1000.as_ref() {
                            __protocol.write_struct_field(
                                1000,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        if let Some(value) = self.check_false.as_ref() {
                            __protocol.write_bool_field(1500, *value)?;
                        }
                        if let Some(value) = self.vertwo2000.as_ref() {
                            __protocol.write_struct_field(
                                2000,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        if let Some(value) = self.a_set2500.as_ref() {
                            __protocol.write_set_field(
                                2500,
                                ::pilota::thrift::TType::Binary,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_faststr((val).clone())?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.vertwo3000.as_ref() {
                            __protocol.write_struct_field(
                                3000,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        if let Some(value) = self.big_numbers.as_ref() {
                            __protocol.write_list_field(
                                4000,
                                ::pilota::thrift::TType::I32,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_i32(*val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_10 = None;
                        let mut var_100 = None;
                        let mut var_500 = None;
                        let mut var_1000 = None;
                        let mut var_1500 = None;
                        let mut var_2000 = None;
                        let mut var_2500 = None;
                        let mut var_3000 = None;
                        let mut var_4000 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(10)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_10 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(100)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_100 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(500)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Bool =>
                                    {
                                        var_500 = Some(__protocol.read_bool()?);
                                    }
                                    Some(1000)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1000 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(1500)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Bool =>
                                    {
                                        var_1500 = Some(__protocol.read_bool()?);
                                    }
                                    Some(2000)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_2000 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(2500)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Set =>
                                    {
                                        var_2500 = Some({
                                            let list_ident = __protocol.read_set_begin()?;
                                            let mut val =
                                                ::pilota::AHashSet::with_capacity(list_ident.size);
                                            for _ in 0..list_ident.size {
                                                val.insert(__protocol.read_faststr()?);
                                            }
                                            __protocol.read_set_end()?;
                                            val
                                        });
                                    }
                                    Some(3000)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_3000 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(4000)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_4000 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<i32> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr()
                                                    .offset(i as isize)
                                                    .write(__protocol.read_i32()?);
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `LargeDeltas` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            b1: var_1,
                            b10: var_10,
                            b100: var_100,
                            check_true: var_500,
                            b1000: var_1000,
                            check_false: var_1500,
                            vertwo2000: var_2000,
                            a_set2500: var_2500,
                            vertwo3000: var_3000,
                            big_numbers: var_4000,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_10 = None;
                            let mut var_100 = None;
                            let mut var_500 = None;
                            let mut var_1000 = None;
                            let mut var_1500 = None;
                            let mut var_2000 = None;
                            let mut var_2500 = None;
                            let mut var_3000 = None;
                            let mut var_4000 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<Bools as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(10) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_10 = Some(<Bools as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(100) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_100 = Some(<Bools as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(500) if field_ident.field_type == ::pilota::thrift::TType::Bool  => {
                    var_500 = Some(__protocol.read_bool().await?);

                },Some(1000) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1000 = Some(<Bools as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(1500) if field_ident.field_type == ::pilota::thrift::TType::Bool  => {
                    var_1500 = Some(__protocol.read_bool().await?);

                },Some(2000) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_2000 = Some(<VersioningTestV2 as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(2500) if field_ident.field_type == ::pilota::thrift::TType::Set  => {
                    var_2500 = Some({let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_faststr().await?);
                    };
                    __protocol.read_set_end().await?;
                    val});

                },Some(3000) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_3000 = Some(<VersioningTestV2 as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(4000) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_4000 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_i32().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `LargeDeltas` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                b1: var_1,
                                b10: var_10,
                                b100: var_100,
                                check_true: var_500,
                                b1000: var_1000,
                                check_false: var_1500,
                                vertwo2000: var_2000,
                                a_set2500: var_2500,
                                vertwo3000: var_3000,
                                big_numbers: var_4000,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "LargeDeltas",
                        }) + self
                            .b1
                            .as_ref()
                            .map_or(0, |value| __protocol.struct_field_len(Some(1), value))
                            + self
                                .b10
                                .as_ref()
                                .map_or(0, |value| __protocol.struct_field_len(Some(10), value))
                            + self
                                .b100
                                .as_ref()
                                .map_or(0, |value| __protocol.struct_field_len(Some(100), value))
                            + self
                                .check_true
                                .as_ref()
                                .map_or(0, |value| __protocol.bool_field_len(Some(500), *value))
                            + self
                                .b1000
                                .as_ref()
                                .map_or(0, |value| __protocol.struct_field_len(Some(1000), value))
                            + self
                                .check_false
                                .as_ref()
                                .map_or(0, |value| __protocol.bool_field_len(Some(1500), *value))
                            + self
                                .vertwo2000
                                .as_ref()
                                .map_or(0, |value| __protocol.struct_field_len(Some(2000), value))
                            + self.a_set2500.as_ref().map_or(0, |value| {
                                __protocol.set_field_len(
                                    Some(2500),
                                    ::pilota::thrift::TType::Binary,
                                    value,
                                    |__protocol, el| __protocol.faststr_len(el),
                                )
                            })
                            + self
                                .vertwo3000
                                .as_ref()
                                .map_or(0, |value| __protocol.struct_field_len(Some(3000), value))
                            + self.big_numbers.as_ref().map_or(0, |value| {
                                __protocol.list_field_len(
                                    Some(4000),
                                    ::pilota::thrift::TType::I32,
                                    value,
                                    |__protocol, el| __protocol.i32_len(*el),
                                )
                            })
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testI32("%d")' with thing as '%d'
                 * @param i32 thing - the i32 to print
                 * @return i32 - returns the i32 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestI32ArgsSend {
                    pub thing: i32,
                }
                impl ::pilota::thrift::Message for ThriftTestTestI32ArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI32ArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i32_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestI32ArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestI32ArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI32ArgsSend",
                        }) + __protocol.i32_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
                 *  separated by commas and new lines
                 * @param set<i32> thing - the set<i32> to print
                 * @return set<i32> - returns the set<i32> 'thing'
                 */
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestSetArgsRecv {
                    pub thing: ::pilota::AHashSet<i32>,
                }
                impl ::pilota::thrift::Message for ThriftTestTestSetArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestSetArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_set_field(
                            1,
                            ::pilota::thrift::TType::I32,
                            &&self.thing,
                            |__protocol, val| {
                                __protocol.write_i32(*val)?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Set =>
                                    {
                                        var_1 = Some({
                                            let list_ident = __protocol.read_set_begin()?;
                                            let mut val =
                                                ::pilota::AHashSet::with_capacity(list_ident.size);
                                            for _ in 0..list_ident.size {
                                                val.insert(__protocol.read_i32()?);
                                            }
                                            __protocol.read_set_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestSetArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Set  => {
                    var_1 = Some({let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_i32().await?);
                    };
                    __protocol.read_set_end().await?;
                    val});

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestSetArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestSetArgsRecv",
                        }) + __protocol.set_field_len(
                            Some(1),
                            ::pilota::thrift::TType::I32,
                            &self.thing,
                            |__protocol, el| __protocol.i32_len(*el),
                        ) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
                 * @param string arg - a string indicating what type of exception to throw
                 * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
                 * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
                 * else do not throw anything
                 * @return Xtruct - an Xtruct with string_thing = arg1
                 */

                impl ::std::default::Default for ThriftTestTestMultiExceptionException {
                    fn default() -> Self {
                        ThriftTestTestMultiExceptionException::Err1(
                            ::std::default::Default::default(),
                        )
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMultiExceptionException {
                    Err1(Xception),

                    Err2(Xception2),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMultiExceptionException {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionException",
                        })?;
                        match self {
                            ThriftTestTestMultiExceptionException::Err1(value) => {
                                __protocol.write_struct_field(
                                    1,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                            ThriftTestTestMultiExceptionException::Err2(value) => {
                                __protocol.write_struct_field(
                                    2,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(1) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiExceptionException::Err1(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(2) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiExceptionException::Err2(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(1) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestMultiExceptionException::Err1(
                                                    field_ident,
                                                ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(2) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception2 as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestMultiExceptionException::Err2(
                                                    field_ident,
                                                ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionException",
                        }) + match self {
                            ThriftTestTestMultiExceptionException::Err1(value) => {
                                __protocol.struct_field_len(Some(1), value)
                            }
                            ThriftTestTestMultiExceptionException::Err2(value) => {
                                __protocol.struct_field_len(Some(2), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints "testVoid()" and returns nothing.
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestVoidArgsSend {}
                impl ::pilota::thrift::Message for ThriftTestTestVoidArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestVoidArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;

                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestVoidArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {};
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {

                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestVoidArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {};
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestVoidArgsSend",
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
                 * @param Xtruct thing - the Xtruct to print
                 * @return Xtruct - returns the Xtruct 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestStructArgsRecv {
                    pub thing: Xtruct,
                }
                impl ::pilota::thrift::Message for ThriftTestTestStructArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStructArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_struct_field(
                            1,
                            &self.thing,
                            ::pilota::thrift::TType::Struct,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestStructArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestStructArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStructArgsRecv",
                        }) + __protocol.struct_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMulti()'
                 * @param i8 arg0 -
                 * @param i32 arg1 -
                 * @param i64 arg2 -
                 * @param map<i16, string> arg3 -
                 * @param Numberz arg4 -
                 * @param UserId arg5 -
                 * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
                 *    and i64_thing = arg2
                 */

                impl ::std::default::Default for ThriftTestTestMultiResultRecv {
                    fn default() -> Self {
                        ThriftTestTestMultiResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMultiResultRecv {
                    /**
                     * Prints 'testMulti()'
                     * @param i8 arg0 -
                     * @param i32 arg1 -
                     * @param i64 arg2 -
                     * @param map<i16, string> arg3 -
                     * @param Numberz arg4 -
                     * @param UserId arg5 -
                     * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
                     *    and i64_thing = arg2
                     */
                    Ok(Xtruct),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMultiResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiResultRecv",
                        })?;
                        match self {
                            ThriftTestTestMultiResultRecv::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestMultiResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiResultRecv",
                        }) + match self {
                            ThriftTestTestMultiResultRecv::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                pub const MY_NUMBERZ: Numberz = Numberz::ONE;

                impl ::std::default::Default for BoolTest {
                    fn default() -> Self {
                        BoolTest {
                            b: Some(true),
                            s: Some(::pilota::FastStr::from_static_str("true")),
                        }
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub struct BoolTest {
                    pub b: ::std::option::Option<bool>,

                    pub s: ::std::option::Option<::pilota::FastStr>,
                }
                impl ::pilota::thrift::Message for BoolTest {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "BoolTest" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.b.as_ref() {
                            __protocol.write_bool_field(1, *value)?;
                        }
                        if let Some(value) = self.s.as_ref() {
                            __protocol.write_faststr_field(2, (value).clone())?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = Some(true);
                        let mut var_2 = Some(::pilota::FastStr::from_static_str("true"));

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Bool =>
                                    {
                                        var_1 = Some(__protocol.read_bool()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_2 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `BoolTest` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self { b: var_1, s: var_2 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = Some(true);
                            let mut var_2 = Some(::pilota::FastStr::from_static_str("true"));

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Bool  => {
                    var_1 = Some(__protocol.read_bool().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_2 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `BoolTest` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self { b: var_1, s: var_2 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "BoolTest",
                        }) + self
                            .b
                            .as_ref()
                            .map_or(0, |value| __protocol.bool_field_len(Some(1), *value))
                            + self
                                .s
                                .as_ref()
                                .map_or(0, |value| __protocol.faststr_field_len(Some(2), value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testI64("%d")' with thing as '%d'
                 * @param i64 thing - the i64 to print
                 * @return i64 - returns the i64 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestI64ArgsRecv {
                    pub thing: i64,
                }
                impl ::pilota::thrift::Message for ThriftTestTestI64ArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI64ArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i64_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_1 = Some(__protocol.read_i64()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestI64ArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_1 = Some(__protocol.read_i64().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestI64ArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI64ArgsRecv",
                        }) + __protocol.i64_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
                 * @param Numberz thing - the Numberz to print
                 * @return Numberz - returns the Numberz 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestEnumResultRecv {
                    fn default() -> Self {
                        ThriftTestTestEnumResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestEnumResultRecv {
                    /**
                     * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
                     * @param Numberz thing - the Numberz to print
                     * @return Numberz - returns the Numberz 'thing'
                     */
                    Ok(Numberz),
                }

                impl ::pilota::thrift::Message for ThriftTestTestEnumResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestEnumResultRecv",
                        })?;
                        match self {
                            ThriftTestTestEnumResultRecv::Ok(value) => {
                                __protocol.write_i32_field(0, (value).inner())?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestEnumResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestEnumResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestEnumResultRecv",
                        }) + match self {
                            ThriftTestTestEnumResultRecv::Ok(value) => {
                                __protocol.i32_field_len(Some(0), (value).inner())
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
                 * sleep 'secondsToSleep'
                 * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
                 * @param i32 secondsToSleep - the number of seconds to sleep
                 */

                impl ::std::default::Default for ThriftTestTestOnewayResultSend {
                    fn default() -> Self {
                        ThriftTestTestOnewayResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestOnewayResultSend {
                    /**
                     * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
                     * sleep 'secondsToSleep'
                     * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
                     * @param i32 secondsToSleep - the number of seconds to sleep
                     */
                    Ok(()),
                }

                impl ::pilota::thrift::Message for ThriftTestTestOnewayResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestOnewayResultSend",
                        })?;
                        match self {
                            ThriftTestTestOnewayResultSend::Ok(value) => {}
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Ok(ThriftTestTestOnewayResultSend::Ok(()))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Ok(ThriftTestTestOnewayResultSend::Ok(()))
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestOnewayResultSend",
                        }) + match self {
                            ThriftTestTestOnewayResultSend::Ok(value) => 0,
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testString("%s")' with thing as '%s'
                 * @param string thing - the string to print
                 * @return string - returns the string 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestStringArgsRecv {
                    pub thing: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for ThriftTestTestStringArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.thing).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestStringArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestStringArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringArgsRecv",
                        }) + __protocol.faststr_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
                 *  separated by commas and new lines
                 * @param map<i32,i32> thing - the map<i32,i32> to print
                 * @return map<i32,i32> - returns the map<i32,i32> 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestMapResultRecv {
                    fn default() -> Self {
                        ThriftTestTestMapResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMapResultRecv {
                    /**
                     * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
                     *  separated by commas and new lines
                     * @param map<i32,i32> thing - the map<i32,i32> to print
                     * @return map<i32,i32> - returns the map<i32,i32> 'thing'
                     */
                    Ok(::pilota::AHashMap<i32, i32>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMapResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapResultRecv",
                        })?;
                        match self {
                            ThriftTestTestMapResultRecv::Ok(value) => {
                                __protocol.write_map_field(
                                    0,
                                    ::pilota::thrift::TType::I32,
                                    ::pilota::thrift::TType::I32,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_i32(*key)?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_i32(*val)?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_i32()?,
                                                    __protocol.read_i32()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::I32,
                                            &field_ident,
                                            |__protocol, key| __protocol.i32_len(*key),
                                            |__protocol, val| __protocol.i32_len(*val),
                                        );
                                        ret = Some(ThriftTestTestMapResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(
                                                        __protocol.read_i32().await?,
                                                        __protocol.read_i32().await?,
                                                    );
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret =
                                                Some(ThriftTestTestMapResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapResultRecv",
                        }) + match self {
                            ThriftTestTestMapResultRecv::Ok(value) => __protocol.map_field_len(
                                Some(0),
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::I32,
                                value,
                                |__protocol, key| __protocol.i32_len(*key),
                                |__protocol, val| __protocol.i32_len(*val),
                            ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct Xtruct3 {
                    pub string_thing: ::std::option::Option<::pilota::FastStr>,

                    pub changed: ::std::option::Option<i32>,

                    pub i32_thing: ::std::option::Option<i32>,

                    pub i64_thing: ::std::option::Option<i64>,
                }
                impl ::pilota::thrift::Message for Xtruct3 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "Xtruct3" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.string_thing.as_ref() {
                            __protocol.write_faststr_field(1, (value).clone())?;
                        }
                        if let Some(value) = self.changed.as_ref() {
                            __protocol.write_i32_field(4, *value)?;
                        }
                        if let Some(value) = self.i32_thing.as_ref() {
                            __protocol.write_i32_field(9, *value)?;
                        }
                        if let Some(value) = self.i64_thing.as_ref() {
                            __protocol.write_i64_field(11, *value)?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_4 = None;
                        let mut var_9 = None;
                        let mut var_11 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    Some(4)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_4 = Some(__protocol.read_i32()?);
                                    }
                                    Some(9)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_9 = Some(__protocol.read_i32()?);
                                    }
                                    Some(11)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_11 = Some(__protocol.read_i64()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `Xtruct3` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            string_thing: var_1,
                            changed: var_4,
                            i32_thing: var_9,
                            i64_thing: var_11,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_4 = None;
                            let mut var_9 = None;
                            let mut var_11 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },Some(4) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_4 = Some(__protocol.read_i32().await?);

                },Some(9) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_9 = Some(__protocol.read_i32().await?);

                },Some(11) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_11 = Some(__protocol.read_i64().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `Xtruct3` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                string_thing: var_1,
                                changed: var_4,
                                i32_thing: var_9,
                                i64_thing: var_11,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "Xtruct3",
                        }) + self
                            .string_thing
                            .as_ref()
                            .map_or(0, |value| __protocol.faststr_field_len(Some(1), value))
                            + self
                                .changed
                                .as_ref()
                                .map_or(0, |value| __protocol.i32_field_len(Some(4), *value))
                            + self
                                .i32_thing
                                .as_ref()
                                .map_or(0, |value| __protocol.i32_field_len(Some(9), *value))
                            + self
                                .i64_thing
                                .as_ref()
                                .map_or(0, |value| __protocol.i64_field_len(Some(11), *value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
                 * @param binary  thing - the binary data to print
                 * @return binary  - returns the binary 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestBinaryResultRecv {
                    fn default() -> Self {
                        ThriftTestTestBinaryResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestBinaryResultRecv {
                    /**
                     * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
                     * @param binary  thing - the binary data to print
                     * @return binary  - returns the binary 'thing'
                     */
                    Ok(::pilota::Bytes),
                }

                impl ::pilota::thrift::Message for ThriftTestTestBinaryResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBinaryResultRecv",
                        })?;
                        match self {
                            ThriftTestTestBinaryResultRecv::Ok(value) => {
                                __protocol.write_bytes_field(0, (value).clone())?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_bytes()?;
                                        __protocol.bytes_len(&field_ident);
                                        ret = Some(ThriftTestTestBinaryResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_bytes().await?;

                                            ret = Some(ThriftTestTestBinaryResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBinaryResultRecv",
                        }) + match self {
                            ThriftTestTestBinaryResultRecv::Ok(value) => {
                                __protocol.bytes_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testString("%s")' with thing as '%s'
                 * @param string thing - the string to print
                 * @return string - returns the string 'thing'
                 */

                impl ::std::default::Default for SecondServiceSecondtestStringResultSend {
                    fn default() -> Self {
                        SecondServiceSecondtestStringResultSend::Ok(
                            ::std::default::Default::default(),
                        )
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum SecondServiceSecondtestStringResultSend {
                    /**
                     * Prints 'testString("%s")' with thing as '%s'
                     * @param string thing - the string to print
                     * @return string - returns the string 'thing'
                     */
                    Ok(::pilota::FastStr),
                }

                impl ::pilota::thrift::Message for SecondServiceSecondtestStringResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "SecondServiceSecondtestStringResultSend",
                        })?;
                        match self {
                            SecondServiceSecondtestStringResultSend::Ok(value) => {
                                __protocol.write_faststr_field(0, (value).clone())?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_faststr()?;
                                        __protocol.faststr_len(&field_ident);
                                        ret = Some(SecondServiceSecondtestStringResultSend::Ok(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_faststr().await?;

                                            ret =
                                                Some(SecondServiceSecondtestStringResultSend::Ok(
                                                    field_ident,
                                                ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "SecondServiceSecondtestStringResultSend",
                        }) + match self {
                            SecondServiceSecondtestStringResultSend::Ok(value) => {
                                __protocol.faststr_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testByte("%d")' with thing as '%d'
                 * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
                 * @param byte thing - the i8/byte to print
                 * @return i8 - returns the i8/byte 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestByteResultRecv {
                    fn default() -> Self {
                        ThriftTestTestByteResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestByteResultRecv {
                    /**
                     * Prints 'testByte("%d")' with thing as '%d'
                     * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
                     * @param byte thing - the i8/byte to print
                     * @return i8 - returns the i8/byte 'thing'
                     */
                    Ok(i8),
                }

                impl ::pilota::thrift::Message for ThriftTestTestByteResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestByteResultRecv",
                        })?;
                        match self {
                            ThriftTestTestByteResultRecv::Ok(value) => {
                                __protocol.write_i8_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_i8()?;
                                        __protocol.i8_len(*&field_ident);
                                        ret = Some(ThriftTestTestByteResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_i8().await?;

                                            ret =
                                                Some(ThriftTestTestByteResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestByteResultRecv",
                        }) + match self {
                            ThriftTestTestByteResultRecv::Ok(value) => {
                                __protocol.i8_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testException(%s)' with arg as '%s'
                 * @param string arg - a string indication what type of exception to throw
                 * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
                 * else if arg == "TException" throw TException
                 * else do not throw anything
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestExceptionArgsSend {
                    pub arg: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for ThriftTestTestExceptionArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.arg).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestExceptionArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { arg: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestExceptionArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { arg: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionArgsSend",
                        }) + __protocol.faststr_field_len(Some(1), &self.arg)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMapMap("%d")' with hello as '%d'
                 * @param i32 hello - the i32 to print
                 * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
                 *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
                 */

                impl ::std::default::Default for ThriftTestTestMapMapResultSend {
                    fn default() -> Self {
                        ThriftTestTestMapMapResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMapMapResultSend {
                    /**
                     * Prints 'testMapMap("%d")' with hello as '%d'
                     * @param i32 hello - the i32 to print
                     * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
                     *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
                     */
                    Ok(::pilota::AHashMap<i32, ::pilota::AHashMap<i32, i32>>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMapMapResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapMapResultSend",
                        })?;
                        match self {
                            ThriftTestTestMapMapResultSend::Ok(value) => {
                                __protocol.write_map_field(
                                    0,
                                    ::pilota::thrift::TType::I32,
                                    ::pilota::thrift::TType::Map,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_i32(*key)?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_map(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::I32,
                                            &val,
                                            |__protocol, key| {
                                                __protocol.write_i32(*key)?;
                                                ::std::result::Result::Ok(())
                                            },
                                            |__protocol, val| {
                                                __protocol.write_i32(*val)?;
                                                ::std::result::Result::Ok(())
                                            },
                                        )?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(__protocol.read_i32()?, {
                                                    let map_ident = __protocol.read_map_begin()?;
                                                    let mut val = ::pilota::AHashMap::with_capacity(
                                                        map_ident.size,
                                                    );
                                                    for _ in 0..map_ident.size {
                                                        val.insert(
                                                            __protocol.read_i32()?,
                                                            __protocol.read_i32()?,
                                                        );
                                                    }
                                                    __protocol.read_map_end()?;
                                                    val
                                                });
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::Map,
                                            &field_ident,
                                            |__protocol, key| __protocol.i32_len(*key),
                                            |__protocol, val| {
                                                __protocol.map_len(
                                                    ::pilota::thrift::TType::I32,
                                                    ::pilota::thrift::TType::I32,
                                                    val,
                                                    |__protocol, key| __protocol.i32_len(*key),
                                                    |__protocol, val| __protocol.i32_len(*val),
                                                )
                                            },
                                        );
                                        ret = Some(ThriftTestTestMapMapResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(__protocol.read_i32().await?, {
                                                        let map_ident =
                                                            __protocol.read_map_begin().await?;
                                                        let mut val =
                                                            ::pilota::AHashMap::with_capacity(
                                                                map_ident.size,
                                                            );
                                                        for _ in 0..map_ident.size {
                                                            val.insert(
                                                                __protocol.read_i32().await?,
                                                                __protocol.read_i32().await?,
                                                            );
                                                        }
                                                        __protocol.read_map_end().await?;
                                                        val
                                                    });
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret = Some(ThriftTestTestMapMapResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapMapResultSend",
                        }) + match self {
                            ThriftTestTestMapMapResultSend::Ok(value) => __protocol.map_field_len(
                                Some(0),
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::Map,
                                value,
                                |__protocol, key| __protocol.i32_len(*key),
                                |__protocol, val| {
                                    __protocol.map_len(
                                        ::pilota::thrift::TType::I32,
                                        ::pilota::thrift::TType::I32,
                                        val,
                                        |__protocol, key| __protocol.i32_len(*key),
                                        |__protocol, val| __protocol.i32_len(*val),
                                    )
                                },
                            ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ListTypeVersioningV1 {
                    pub myints: ::std::option::Option<::std::vec::Vec<i32>>,

                    pub hello: ::std::option::Option<::pilota::FastStr>,
                }
                impl ::pilota::thrift::Message for ListTypeVersioningV1 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ListTypeVersioningV1",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.myints.as_ref() {
                            __protocol.write_list_field(
                                1,
                                ::pilota::thrift::TType::I32,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_i32(*val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.hello.as_ref() {
                            __protocol.write_faststr_field(2, (value).clone())?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<i32> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr()
                                                    .offset(i as isize)
                                                    .write(__protocol.read_i32()?);
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_2 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ListTypeVersioningV1` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            myints: var_1,
                            hello: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_i32().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_2 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ListTypeVersioningV1` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                myints: var_1,
                                hello: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ListTypeVersioningV1",
                        }) + self.myints.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(1),
                                ::pilota::thrift::TType::I32,
                                value,
                                |__protocol, el| __protocol.i32_len(*el),
                            )
                        }) + self
                            .hello
                            .as_ref()
                            .map_or(0, |value| __protocol.faststr_field_len(Some(2), value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
                 *  separated by commas and new lines
                 * @param set<i32> thing - the set<i32> to print
                 * @return set<i32> - returns the set<i32> 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestSetResultSend {
                    fn default() -> Self {
                        ThriftTestTestSetResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestSetResultSend {
                    /**
                     * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
                     *  separated by commas and new lines
                     * @param set<i32> thing - the set<i32> to print
                     * @return set<i32> - returns the set<i32> 'thing'
                     */
                    Ok(::pilota::AHashSet<i32>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestSetResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestSetResultSend",
                        })?;
                        match self {
                            ThriftTestTestSetResultSend::Ok(value) => {
                                __protocol.write_set_field(
                                    0,
                                    ::pilota::thrift::TType::I32,
                                    &value,
                                    |__protocol, val| {
                                        __protocol.write_i32(*val)?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let list_ident = __protocol.read_set_begin()?;
                                            let mut val =
                                                ::pilota::AHashSet::with_capacity(list_ident.size);
                                            for _ in 0..list_ident.size {
                                                val.insert(__protocol.read_i32()?);
                                            }
                                            __protocol.read_set_end()?;
                                            val
                                        };
                                        __protocol.set_len(
                                            ::pilota::thrift::TType::I32,
                                            &field_ident,
                                            |__protocol, el| __protocol.i32_len(*el),
                                        );
                                        ret = Some(ThriftTestTestSetResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let list_ident =
                                                    __protocol.read_set_begin().await?;
                                                let mut val = ::pilota::AHashSet::with_capacity(
                                                    list_ident.size,
                                                );
                                                for _ in 0..list_ident.size {
                                                    val.insert(__protocol.read_i32().await?);
                                                }
                                                __protocol.read_set_end().await?;
                                                val
                                            };

                                            ret =
                                                Some(ThriftTestTestSetResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestSetResultSend",
                        }) + match self {
                            ThriftTestTestSetResultSend::Ok(value) => __protocol.set_field_len(
                                Some(0),
                                ::pilota::thrift::TType::I32,
                                value,
                                |__protocol, el| __protocol.i32_len(*el),
                            ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
                 * @param Xtruct thing - the Xtruct to print
                 * @return Xtruct - returns the Xtruct 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestStructResultSend {
                    fn default() -> Self {
                        ThriftTestTestStructResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestStructResultSend {
                    /**
                     * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
                     * @param Xtruct thing - the Xtruct to print
                     * @return Xtruct - returns the Xtruct 'thing'
                     */
                    Ok(Xtruct),
                }

                impl ::pilota::thrift::Message for ThriftTestTestStructResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStructResultSend",
                        })?;
                        match self {
                            ThriftTestTestStructResultSend::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestStructResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestStructResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStructResultSend",
                        }) + match self {
                            ThriftTestTestStructResultSend::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct NestedMixedx2 {
                    pub int_set_list:
                        ::std::option::Option<::std::vec::Vec<::pilota::AHashSet<i32>>>,

                    pub map_int_strset: ::std::option::Option<
                        ::pilota::AHashMap<i32, ::pilota::AHashSet<::pilota::FastStr>>,
                    >,

                    pub map_int_strset_list: ::std::option::Option<
                        ::std::vec::Vec<
                            ::pilota::AHashMap<i32, ::pilota::AHashSet<::pilota::FastStr>>,
                        >,
                    >,
                }
                impl ::pilota::thrift::Message for NestedMixedx2 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "NestedMixedx2",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.int_set_list.as_ref() {
                            __protocol.write_list_field(
                                1,
                                ::pilota::thrift::TType::Set,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_set(
                                        ::pilota::thrift::TType::I32,
                                        &val,
                                        |__protocol, val| {
                                            __protocol.write_i32(*val)?;
                                            ::std::result::Result::Ok(())
                                        },
                                    )?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.map_int_strset.as_ref() {
                            __protocol.write_map_field(
                                2,
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::Set,
                                &value,
                                |__protocol, key| {
                                    __protocol.write_i32(*key)?;
                                    ::std::result::Result::Ok(())
                                },
                                |__protocol, val| {
                                    __protocol.write_set(
                                        ::pilota::thrift::TType::Binary,
                                        &val,
                                        |__protocol, val| {
                                            __protocol.write_faststr((val).clone())?;
                                            ::std::result::Result::Ok(())
                                        },
                                    )?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.map_int_strset_list.as_ref() {
                            __protocol.write_list_field(
                                3,
                                ::pilota::thrift::TType::Map,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_map(
                                        ::pilota::thrift::TType::I32,
                                        ::pilota::thrift::TType::Set,
                                        &val,
                                        |__protocol, key| {
                                            __protocol.write_i32(*key)?;
                                            ::std::result::Result::Ok(())
                                        },
                                        |__protocol, val| {
                                            __protocol.write_set(
                                                ::pilota::thrift::TType::Binary,
                                                &val,
                                                |__protocol, val| {
                                                    __protocol.write_faststr((val).clone())?;
                                                    ::std::result::Result::Ok(())
                                                },
                                            )?;
                                            ::std::result::Result::Ok(())
                                        },
                                    )?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;
                        let mut var_3 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<::pilota::AHashSet<i32>> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write({
                                                    let list_ident = __protocol.read_set_begin()?;
                                                    let mut val = ::pilota::AHashSet::with_capacity(
                                                        list_ident.size,
                                                    );
                                                    for _ in 0..list_ident.size {
                                                        val.insert(__protocol.read_i32()?);
                                                    }
                                                    __protocol.read_set_end()?;
                                                    val
                                                });
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_2 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(__protocol.read_i32()?, {
                                                    let list_ident = __protocol.read_set_begin()?;
                                                    let mut val = ::pilota::AHashSet::with_capacity(
                                                        list_ident.size,
                                                    );
                                                    for _ in 0..list_ident.size {
                                                        val.insert(__protocol.read_faststr()?);
                                                    }
                                                    __protocol.read_set_end()?;
                                                    val
                                                });
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    Some(3)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_3 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<
                                                ::pilota::AHashMap<
                                                    i32,
                                                    ::pilota::AHashSet<::pilota::FastStr>,
                                                >,
                                            > = ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write({
                                                    let map_ident = __protocol.read_map_begin()?;
                                                    let mut val = ::pilota::AHashMap::with_capacity(
                                                        map_ident.size,
                                                    );
                                                    for _ in 0..map_ident.size {
                                                        val.insert(__protocol.read_i32()?, {
                                                            let list_ident =
                                                                __protocol.read_set_begin()?;
                                                            let mut val =
                                                                ::pilota::AHashSet::with_capacity(
                                                                    list_ident.size,
                                                                );
                                                            for _ in 0..list_ident.size {
                                                                val.insert(
                                                                    __protocol.read_faststr()?,
                                                                );
                                                            }
                                                            __protocol.read_set_end()?;
                                                            val
                                                        });
                                                    }
                                                    __protocol.read_map_end()?;
                                                    val
                                                });
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `NestedMixedx2` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            int_set_list: var_1,
                            map_int_strset: var_2,
                            map_int_strset_list: var_3,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;
                            let mut var_3 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_i32().await?);
                    };
                    __protocol.read_set_end().await?;
                    val});
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_2 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i32().await?, {let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_faststr().await?);
                    };
                    __protocol.read_set_end().await?;
                    val});
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },Some(3) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_3 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i32().await?, {let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_faststr().await?);
                    };
                    __protocol.read_set_end().await?;
                    val});
                        }
                        __protocol.read_map_end().await?;
                        val
                    });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `NestedMixedx2` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                int_set_list: var_1,
                                map_int_strset: var_2,
                                map_int_strset_list: var_3,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "NestedMixedx2",
                        }) + self.int_set_list.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(1),
                                ::pilota::thrift::TType::Set,
                                value,
                                |__protocol, el| {
                                    __protocol.set_len(
                                        ::pilota::thrift::TType::I32,
                                        el,
                                        |__protocol, el| __protocol.i32_len(*el),
                                    )
                                },
                            )
                        }) + self.map_int_strset.as_ref().map_or(0, |value| {
                            __protocol.map_field_len(
                                Some(2),
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::Set,
                                value,
                                |__protocol, key| __protocol.i32_len(*key),
                                |__protocol, val| {
                                    __protocol.set_len(
                                        ::pilota::thrift::TType::Binary,
                                        val,
                                        |__protocol, el| __protocol.faststr_len(el),
                                    )
                                },
                            )
                        }) + self.map_int_strset_list.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(3),
                                ::pilota::thrift::TType::Map,
                                value,
                                |__protocol, el| {
                                    __protocol.map_len(
                                        ::pilota::thrift::TType::I32,
                                        ::pilota::thrift::TType::Set,
                                        el,
                                        |__protocol, key| __protocol.i32_len(*key),
                                        |__protocol, val| {
                                            __protocol.set_len(
                                                ::pilota::thrift::TType::Binary,
                                                val,
                                                |__protocol, el| __protocol.faststr_len(el),
                                            )
                                        },
                                    )
                                },
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testI64("%d")' with thing as '%d'
                 * @param i64 thing - the i64 to print
                 * @return i64 - returns the i64 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestI64ResultSend {
                    fn default() -> Self {
                        ThriftTestTestI64ResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestI64ResultSend {
                    /**
                     * Prints 'testI64("%d")' with thing as '%d'
                     * @param i64 thing - the i64 to print
                     * @return i64 - returns the i64 'thing'
                     */
                    Ok(i64),
                }

                impl ::pilota::thrift::Message for ThriftTestTestI64ResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI64ResultSend",
                        })?;
                        match self {
                            ThriftTestTestI64ResultSend::Ok(value) => {
                                __protocol.write_i64_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_i64()?;
                                        __protocol.i64_len(*&field_ident);
                                        ret = Some(ThriftTestTestI64ResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_i64().await?;

                                            ret =
                                                Some(ThriftTestTestI64ResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI64ResultSend",
                        }) + match self {
                            ThriftTestTestI64ResultSend::Ok(value) => {
                                __protocol.i64_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
                 * @param string arg - a string indicating what type of exception to throw
                 * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
                 * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
                 * else do not throw anything
                 * @return Xtruct - an Xtruct with string_thing = arg1
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestMultiExceptionArgsRecv {
                    pub arg0: ::pilota::FastStr,

                    pub arg1: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for ThriftTestTestMultiExceptionArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.arg0).clone())?;
                        __protocol.write_faststr_field(2, (&self.arg1).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_2 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestMultiExceptionArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg0 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_2) = var_2 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg1 is required".to_string(),
                                ),
                            );
                        };

                        let data = Self {
                            arg0: var_1,
                            arg1: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_2 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestMultiExceptionArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg0 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_2) = var_2 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg1 is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self {
                                arg0: var_1,
                                arg1: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionArgsRecv",
                        }) + __protocol.faststr_field_len(Some(1), &self.arg0)
                            + __protocol.faststr_field_len(Some(2), &self.arg1)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testString("%s")' with thing as '%s'
                 * @param string thing - the string to print
                 * @return string - returns the string 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestStringResultSend {
                    fn default() -> Self {
                        ThriftTestTestStringResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestStringResultSend {
                    /**
                     * Prints 'testString("%s")' with thing as '%s'
                     * @param string thing - the string to print
                     * @return string - returns the string 'thing'
                     */
                    Ok(::pilota::FastStr),
                }

                impl ::pilota::thrift::Message for ThriftTestTestStringResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringResultSend",
                        })?;
                        match self {
                            ThriftTestTestStringResultSend::Ok(value) => {
                                __protocol.write_faststr_field(0, (value).clone())?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_faststr()?;
                                        __protocol.faststr_len(&field_ident);
                                        ret = Some(ThriftTestTestStringResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_faststr().await?;

                                            ret = Some(ThriftTestTestStringResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringResultSend",
                        }) + match self {
                            ThriftTestTestStringResultSend::Ok(value) => {
                                __protocol.faststr_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMulti()'
                 * @param i8 arg0 -
                 * @param i32 arg1 -
                 * @param i64 arg2 -
                 * @param map<i16, string> arg3 -
                 * @param Numberz arg4 -
                 * @param UserId arg5 -
                 * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
                 *    and i64_thing = arg2
                 */
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestMultiArgsSend {
                    pub arg0: i8,

                    pub arg1: i32,

                    pub arg2: i64,

                    pub arg3: ::pilota::AHashMap<i16, ::pilota::FastStr>,

                    pub arg4: Numberz,

                    pub arg5: UserId,
                }
                impl ::pilota::thrift::Message for ThriftTestTestMultiArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i8_field(1, *&self.arg0)?;
                        __protocol.write_i32_field(2, *&self.arg1)?;
                        __protocol.write_i64_field(3, *&self.arg2)?;
                        __protocol.write_map_field(
                            4,
                            ::pilota::thrift::TType::I16,
                            ::pilota::thrift::TType::Binary,
                            &&self.arg3,
                            |__protocol, key| {
                                __protocol.write_i16(*key)?;
                                ::std::result::Result::Ok(())
                            },
                            |__protocol, val| {
                                __protocol.write_faststr((val).clone())?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_i32_field(5, (&self.arg4).inner())?;
                        __protocol.write_struct_field(
                            6,
                            &self.arg5,
                            ::pilota::thrift::TType::I64,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;
                        let mut var_3 = None;
                        let mut var_4 = None;
                        let mut var_5 = None;
                        let mut var_6 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I8 =>
                                    {
                                        var_1 = Some(__protocol.read_i8()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_2 = Some(__protocol.read_i32()?);
                                    }
                                    Some(3)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_3 = Some(__protocol.read_i64()?);
                                    }
                                    Some(4)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_4 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_i16()?,
                                                    __protocol.read_faststr()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    Some(5)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_5 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(6)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_6 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestMultiArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg0 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_2) = var_2 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg1 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_3) = var_3 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg2 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_4) = var_4 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg3 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_5) = var_5 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg4 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_6) = var_6 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg5 is required".to_string(),
                                ),
                            );
                        };

                        let data = Self {
                            arg0: var_1,
                            arg1: var_2,
                            arg2: var_3,
                            arg3: var_4,
                            arg4: var_5,
                            arg5: var_6,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;
                            let mut var_3 = None;
                            let mut var_4 = None;
                            let mut var_5 = None;
                            let mut var_6 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I8  => {
                    var_1 = Some(__protocol.read_i8().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_2 = Some(__protocol.read_i32().await?);

                },Some(3) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_3 = Some(__protocol.read_i64().await?);

                },Some(4) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_4 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i16().await?, __protocol.read_faststr().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },Some(5) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_5 = Some(<Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(6) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_6 = Some(<UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestMultiArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg0 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_2) = var_2 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg1 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_3) = var_3 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg2 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_4) = var_4 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg3 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_5) = var_5 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg4 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_6) = var_6 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg5 is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self {
                                arg0: var_1,
                                arg1: var_2,
                                arg2: var_3,
                                arg3: var_4,
                                arg4: var_5,
                                arg5: var_6,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiArgsSend",
                        }) + __protocol.i8_field_len(Some(1), *&self.arg0)
                            + __protocol.i32_field_len(Some(2), *&self.arg1)
                            + __protocol.i64_field_len(Some(3), *&self.arg2)
                            + __protocol.map_field_len(
                                Some(4),
                                ::pilota::thrift::TType::I16,
                                ::pilota::thrift::TType::Binary,
                                &self.arg3,
                                |__protocol, key| __protocol.i16_len(*key),
                                |__protocol, val| __protocol.faststr_len(val),
                            )
                            + __protocol.i32_field_len(Some(5), (&self.arg4).inner())
                            + __protocol.struct_field_len(Some(6), &self.arg5)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct Bools {
                    pub im_true: ::std::option::Option<bool>,

                    pub im_false: ::std::option::Option<bool>,
                }
                impl ::pilota::thrift::Message for Bools {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "Bools" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.im_true.as_ref() {
                            __protocol.write_bool_field(1, *value)?;
                        }
                        if let Some(value) = self.im_false.as_ref() {
                            __protocol.write_bool_field(2, *value)?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Bool =>
                                    {
                                        var_1 = Some(__protocol.read_bool()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Bool =>
                                    {
                                        var_2 = Some(__protocol.read_bool()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `Bools` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            im_true: var_1,
                            im_false: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Bool  => {
                    var_1 = Some(__protocol.read_bool().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Bool  => {
                    var_2 = Some(__protocol.read_bool().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `Bools` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                im_true: var_1,
                                im_false: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "Bools",
                        }) + self
                            .im_true
                            .as_ref()
                            .map_or(0, |value| __protocol.bool_field_len(Some(1), *value))
                            + self
                                .im_false
                                .as_ref()
                                .map_or(0, |value| __protocol.bool_field_len(Some(2), *value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                impl ::std::default::Default for OptionalBinary {
                    fn default() -> Self {
                        OptionalBinary {
                            bin_map: Some({
                                let mut map = ::pilota::AHashMap::with_capacity(0);

                                map
                            }),
                        }
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub struct OptionalBinary {
                    //1: optional set<binary> bin_set = []
                    pub bin_map: ::std::option::Option<::pilota::AHashMap<::pilota::Bytes, i32>>,
                }
                impl ::pilota::thrift::Message for OptionalBinary {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "OptionalBinary",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.bin_map.as_ref() {
                            __protocol.write_map_field(
                                2,
                                ::pilota::thrift::TType::Binary,
                                ::pilota::thrift::TType::I32,
                                &value,
                                |__protocol, key| {
                                    __protocol.write_bytes(key.clone())?;
                                    ::std::result::Result::Ok(())
                                },
                                |__protocol, val| {
                                    __protocol.write_i32(*val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_2 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_bytes()?,
                                                    __protocol.read_i32()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `OptionalBinary` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        if var_2.is_none() {
                            var_2 = Some({
                                let mut map = ::pilota::AHashMap::with_capacity(0);

                                map
                            });
                        }

                        let data = Self { bin_map: var_2 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(2) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_2 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_bytes().await?, __protocol.read_i32().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `OptionalBinary` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            if var_2.is_none() {
                                var_2 = Some({
                                    let mut map = ::pilota::AHashMap::with_capacity(0);

                                    map
                                });
                            }

                            let data = Self { bin_map: var_2 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "OptionalBinary",
                        }) + self.bin_map.as_ref().map_or(0, |value| {
                            __protocol.map_field_len(
                                Some(2),
                                ::pilota::thrift::TType::Binary,
                                ::pilota::thrift::TType::I32,
                                value,
                                |__protocol, key| __protocol.bytes_len(key),
                                |__protocol, val| __protocol.i32_len(*val),
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
                 * @param Numberz thing - the Numberz to print
                 * @return Numberz - returns the Numberz 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestEnumArgsSend {
                    pub thing: Numberz,
                }
                impl ::pilota::thrift::Message for ThriftTestTestEnumArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestEnumArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i32_field(1, (&self.thing).inner())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestEnumArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(<Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestEnumArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestEnumArgsSend",
                        }) + __protocol.i32_field_len(Some(1), (&self.thing).inner())
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                pub trait ThriftTest {}

                /**
                 * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
                 *  separated by commas and new lines
                 * @param map<i32,i32> thing - the map<i32,i32> to print
                 * @return map<i32,i32> - returns the map<i32,i32> 'thing'
                 */
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestMapArgsSend {
                    pub thing: ::pilota::AHashMap<i32, i32>,
                }
                impl ::pilota::thrift::Message for ThriftTestTestMapArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_map_field(
                            1,
                            ::pilota::thrift::TType::I32,
                            ::pilota::thrift::TType::I32,
                            &&self.thing,
                            |__protocol, key| {
                                __protocol.write_i32(*key)?;
                                ::std::result::Result::Ok(())
                            },
                            |__protocol, val| {
                                __protocol.write_i32(*val)?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_1 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_i32()?,
                                                    __protocol.read_i32()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestMapArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_1 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i32().await?, __protocol.read_i32().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestMapArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapArgsSend",
                        }) + __protocol.map_field_len(
                            Some(1),
                            ::pilota::thrift::TType::I32,
                            ::pilota::thrift::TType::I32,
                            &self.thing,
                            |__protocol, key| __protocol.i32_len(*key),
                            |__protocol, val| __protocol.i32_len(*val),
                        ) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
                 * @param binary  thing - the binary data to print
                 * @return binary  - returns the binary 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestBinaryArgsSend {
                    pub thing: ::pilota::Bytes,
                }
                impl ::pilota::thrift::Message for ThriftTestTestBinaryArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBinaryArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_bytes_field(1, (&self.thing).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_bytes()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestBinaryArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_bytes().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestBinaryArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBinaryArgsSend",
                        }) + __protocol.bytes_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testTypedef("%d")' with thing as '%d'
                 * @param UserId thing - the UserId to print
                 * @return UserId - returns the UserId 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestTypedefArgsRecv {
                    pub thing: UserId,
                }
                impl ::pilota::thrift::Message for ThriftTestTestTypedefArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestTypedefArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_struct_field(
                            1,
                            &self.thing,
                            ::pilota::thrift::TType::I64,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestTypedefArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_1 = Some(<UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestTypedefArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestTypedefArgsRecv",
                        }) + __protocol.struct_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                pub trait SecondService {}

                /**
                 * Prints 'testByte("%d")' with thing as '%d'
                 * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
                 * @param byte thing - the i8/byte to print
                 * @return i8 - returns the i8/byte 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestByteArgsSend {
                    pub thing: i8,
                }
                impl ::pilota::thrift::Message for ThriftTestTestByteArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestByteArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i8_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I8 =>
                                    {
                                        var_1 = Some(__protocol.read_i8()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestByteArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I8  => {
                    var_1 = Some(__protocol.read_i8().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestByteArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestByteArgsSend",
                        }) + __protocol.i8_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
                 *  separated by commas and new lines
                 * @param map<string,string> thing - the map<string,string> to print
                 * @return map<string,string> - returns the map<string,string> 'thing'
                 */
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestStringMapArgsRecv {
                    pub thing: ::pilota::AHashMap<::pilota::FastStr, ::pilota::FastStr>,
                }
                impl ::pilota::thrift::Message for ThriftTestTestStringMapArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringMapArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_map_field(
                            1,
                            ::pilota::thrift::TType::Binary,
                            ::pilota::thrift::TType::Binary,
                            &&self.thing,
                            |__protocol, key| {
                                __protocol.write_faststr((key).clone())?;
                                ::std::result::Result::Ok(())
                            },
                            |__protocol, val| {
                                __protocol.write_faststr((val).clone())?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_1 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_faststr()?,
                                                    __protocol.read_faststr()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestStringMapArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_1 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_faststr().await?, __protocol.read_faststr().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestStringMapArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringMapArgsRecv",
                        }) + __protocol.map_field_len(
                            Some(1),
                            ::pilota::thrift::TType::Binary,
                            ::pilota::thrift::TType::Binary,
                            &self.thing,
                            |__protocol, key| __protocol.faststr_len(key),
                            |__protocol, val| __protocol.faststr_len(val),
                        ) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct EmptyStruct {}
                impl ::pilota::thrift::Message for EmptyStruct {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "EmptyStruct",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;

                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `EmptyStruct` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {};
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {

                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `EmptyStruct` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {};
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "EmptyStruct",
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testUuid("%s")' where '%s' is the uuid given. Note that the uuid byte order should be correct.
                 * @param uuid  thing - the uuid to print
                 * @return uuid  - returns the uuid 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestUuidArgsRecv {
                    pub thing: [u8; 16],
                }
                impl ::pilota::thrift::Message for ThriftTestTestUuidArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestUuidArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_uuid_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Uuid =>
                                    {
                                        var_1 = Some(__protocol.read_uuid()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestUuidArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Uuid  => {
                    var_1 = Some(__protocol.read_uuid().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestUuidArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestUuidArgsRecv",
                        }) + __protocol.uuid_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * So you think you've got this all worked out, eh?
                 *
                 * Creates a map with these values and prints it out:
                 *   { 1 => { 2 => argument,
                 *            3 => argument,
                 *          },
                 *     2 => { 6 => <empty Insanity struct>, },
                 *   }
                 * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
                 */

                impl ::std::default::Default for ThriftTestTestInsanityResultRecv {
                    fn default() -> Self {
                        ThriftTestTestInsanityResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestInsanityResultRecv {
                    /**
                     * So you think you've got this all worked out, eh?
                     *
                     * Creates a map with these values and prints it out:
                     *   { 1 => { 2 => argument,
                     *            3 => argument,
                     *          },
                     *     2 => { 6 => <empty Insanity struct>, },
                     *   }
                     * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
                     */
                    Ok(::pilota::AHashMap<UserId, ::pilota::AHashMap<Numberz, Insanity>>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestInsanityResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestInsanityResultRecv",
                        })?;
                        match self {
                            ThriftTestTestInsanityResultRecv::Ok(value) => {
                                __protocol.write_map_field(
                                    0,
                                    ::pilota::thrift::TType::I64,
                                    ::pilota::thrift::TType::Map,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_struct(key)?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_map(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::Struct,
                                            &val,
                                            |__protocol, key| {
                                                __protocol.write_struct(key)?;
                                                ::std::result::Result::Ok(())
                                            },
                                            |__protocol, val| {
                                                __protocol.write_struct(val)?;
                                                ::std::result::Result::Ok(())
                                            },
                                        )?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    ::pilota::thrift::Message::decode(__protocol)?,
                                                    {
                                                        let map_ident =
                                                            __protocol.read_map_begin()?;
                                                        let mut val =
                                                            ::pilota::AHashMap::with_capacity(
                                                                map_ident.size,
                                                            );
                                                        for _ in 0..map_ident.size {
                                                            val.insert(
                                                                ::pilota::thrift::Message::decode(
                                                                    __protocol,
                                                                )?,
                                                                ::pilota::thrift::Message::decode(
                                                                    __protocol,
                                                                )?,
                                                            );
                                                        }
                                                        __protocol.read_map_end()?;
                                                        val
                                                    },
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I64,
                                            ::pilota::thrift::TType::Map,
                                            &field_ident,
                                            |__protocol, key| __protocol.struct_len(key),
                                            |__protocol, val| {
                                                __protocol.map_len(
                                                    ::pilota::thrift::TType::I32,
                                                    ::pilota::thrift::TType::Struct,
                                                    val,
                                                    |__protocol, key| __protocol.struct_len(key),
                                                    |__protocol, val| __protocol.struct_len(val),
                                                )
                                            },
                                        );
                                        ret =
                                            Some(ThriftTestTestInsanityResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(<UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?, {
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(<Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?, <Insanity as ::pilota::thrift::Message>::decode_async(__protocol).await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret = Some(ThriftTestTestInsanityResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestInsanityResultRecv",
                        }) + match self {
                            ThriftTestTestInsanityResultRecv::Ok(value) => __protocol
                                .map_field_len(
                                    Some(0),
                                    ::pilota::thrift::TType::I64,
                                    ::pilota::thrift::TType::Map,
                                    value,
                                    |__protocol, key| __protocol.struct_len(key),
                                    |__protocol, val| {
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::Struct,
                                            val,
                                            |__protocol, key| __protocol.struct_len(key),
                                            |__protocol, val| __protocol.struct_len(val),
                                        )
                                    },
                                ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct NestedListsI32x2 {
                    pub integerlist: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<i32>>>,
                }
                impl ::pilota::thrift::Message for NestedListsI32x2 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "NestedListsI32x2",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.integerlist.as_ref() {
                            __protocol.write_list_field(
                                1,
                                ::pilota::thrift::TType::List,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_list(
                                        ::pilota::thrift::TType::I32,
                                        &val,
                                        |__protocol, val| {
                                            __protocol.write_i32(*val)?;
                                            ::std::result::Result::Ok(())
                                        },
                                    )?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<::std::vec::Vec<i32>> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write(unsafe {
                                                    let list_ident =
                                                        __protocol.read_list_begin()?;
                                                    let mut val: ::std::vec::Vec<i32> =
                                                        ::std::vec::Vec::with_capacity(
                                                            list_ident.size,
                                                        );
                                                    for i in 0..list_ident.size {
                                                        val.as_mut_ptr()
                                                            .offset(i as isize)
                                                            .write(__protocol.read_i32()?);
                                                    }
                                                    val.set_len(list_ident.size);
                                                    __protocol.read_list_end()?;
                                                    val
                                                });
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `NestedListsI32x2` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self { integerlist: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_i32().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `NestedListsI32x2` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self { integerlist: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "NestedListsI32x2",
                        }) + self.integerlist.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(1),
                                ::pilota::thrift::TType::List,
                                value,
                                |__protocol, el| {
                                    __protocol.list_len(
                                        ::pilota::thrift::TType::I32,
                                        el,
                                        |__protocol, el| __protocol.i32_len(*el),
                                    )
                                },
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testI32("%d")' with thing as '%d'
                 * @param i32 thing - the i32 to print
                 * @return i32 - returns the i32 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestI32ArgsRecv {
                    pub thing: i32,
                }
                impl ::pilota::thrift::Message for ThriftTestTestI32ArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI32ArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i32_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestI32ArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestI32ArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI32ArgsRecv",
                        }) + __protocol.i32_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testList("{%s}")' where thing has been formatted into a string of values
                 *  separated by commas and new lines
                 * @param list<i32> thing - the list<i32> to print
                 * @return list<i32> - returns the list<i32> 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestListResultRecv {
                    fn default() -> Self {
                        ThriftTestTestListResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestListResultRecv {
                    /**
                     * Prints 'testList("{%s}")' where thing has been formatted into a string of values
                     *  separated by commas and new lines
                     * @param list<i32> thing - the list<i32> to print
                     * @return list<i32> - returns the list<i32> 'thing'
                     */
                    Ok(::std::vec::Vec<i32>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestListResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestListResultRecv",
                        })?;
                        match self {
                            ThriftTestTestListResultRecv::Ok(value) => {
                                __protocol.write_list_field(
                                    0,
                                    ::pilota::thrift::TType::I32,
                                    &value,
                                    |__protocol, val| {
                                        __protocol.write_i32(*val)?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<i32> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr()
                                                    .offset(i as isize)
                                                    .write(__protocol.read_i32()?);
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        };
                                        __protocol.list_len(
                                            ::pilota::thrift::TType::I32,
                                            &field_ident,
                                            |__protocol, el| __protocol.i32_len(*el),
                                        );
                                        ret = Some(ThriftTestTestListResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let list_ident =
                                                    __protocol.read_list_begin().await?;
                                                let mut val =
                                                    ::std::vec::Vec::with_capacity(list_ident.size);
                                                for _ in 0..list_ident.size {
                                                    val.push(__protocol.read_i32().await?);
                                                }
                                                __protocol.read_list_end().await?;
                                                val
                                            };

                                            ret =
                                                Some(ThriftTestTestListResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestListResultRecv",
                        }) + match self {
                            ThriftTestTestListResultRecv::Ok(value) => __protocol.list_field_len(
                                Some(0),
                                ::pilota::thrift::TType::I32,
                                value,
                                |__protocol, el| __protocol.i32_len(*el),
                            ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints "testVoid()" and returns nothing.
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestVoidArgsRecv {}
                impl ::pilota::thrift::Message for ThriftTestTestVoidArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestVoidArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;

                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestVoidArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {};
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {

                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestVoidArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {};
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestVoidArgsRecv",
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
                 * @param Xtruct2 thing - the Xtruct2 to print
                 * @return Xtruct2 - returns the Xtruct2 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestNestResultRecv {
                    fn default() -> Self {
                        ThriftTestTestNestResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestNestResultRecv {
                    /**
                     * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
                     * @param Xtruct2 thing - the Xtruct2 to print
                     * @return Xtruct2 - returns the Xtruct2 'thing'
                     */
                    Ok(Xtruct2),
                }

                impl ::pilota::thrift::Message for ThriftTestTestNestResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestNestResultRecv",
                        })?;
                        match self {
                            ThriftTestTestNestResultRecv::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestNestResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct2 as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestNestResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestNestResultRecv",
                        }) + match self {
                            ThriftTestTestNestResultRecv::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                // the following is expected to fail:

                // const Numberz urNumberz = ONE;
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct UserId(pub i64);

                impl ::std::ops::Deref for UserId {
                    type Target = i64;

                    fn deref(&self) -> &Self::Target {
                        &self.0
                    }
                }

                impl From<i64> for UserId {
                    fn from(v: i64) -> Self {
                        Self(v)
                    }
                }

                impl ::pilota::thrift::Message for UserId {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_i64(*(&**self))?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        ::std::result::Result::Ok(UserId(__protocol.read_i64()?))
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            ::std::result::Result::Ok(UserId(__protocol.read_i64().await?))
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.i64_len(*&**self)
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct StructA {
                    pub s: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for StructA {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "StructA" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.s).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `StructA` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field s is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { s: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `StructA` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field s is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { s: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "StructA",
                        }) + __protocol.faststr_field_len(Some(1), &self.s)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testDouble("%f")' with thing as '%f'
                 * @param double thing - the double to print
                 * @return double - returns the double 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestDoubleResultRecv {
                    fn default() -> Self {
                        ThriftTestTestDoubleResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestDoubleResultRecv {
                    /**
                     * Prints 'testDouble("%f")' with thing as '%f'
                     * @param double thing - the double to print
                     * @return double - returns the double 'thing'
                     */
                    Ok(f64),
                }

                impl ::pilota::thrift::Message for ThriftTestTestDoubleResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestDoubleResultRecv",
                        })?;
                        match self {
                            ThriftTestTestDoubleResultRecv::Ok(value) => {
                                __protocol.write_double_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_double()?;
                                        __protocol.double_len(*&field_ident);
                                        ret = Some(ThriftTestTestDoubleResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_double().await?;

                                            ret = Some(ThriftTestTestDoubleResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestDoubleResultRecv",
                        }) + match self {
                            ThriftTestTestDoubleResultRecv::Ok(value) => {
                                __protocol.double_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
                 * @param bool  thing - the bool data to print
                 * @return bool  - returns the bool 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestBoolResultRecv {
                    fn default() -> Self {
                        ThriftTestTestBoolResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestBoolResultRecv {
                    /**
                     * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
                     * @param bool  thing - the bool data to print
                     * @return bool  - returns the bool 'thing'
                     */
                    Ok(bool),
                }

                impl ::pilota::thrift::Message for ThriftTestTestBoolResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBoolResultRecv",
                        })?;
                        match self {
                            ThriftTestTestBoolResultRecv::Ok(value) => {
                                __protocol.write_bool_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_bool()?;
                                        __protocol.bool_len(*&field_ident);
                                        ret = Some(ThriftTestTestBoolResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_bool().await?;

                                            ret =
                                                Some(ThriftTestTestBoolResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBoolResultRecv",
                        }) + match self {
                            ThriftTestTestBoolResultRecv::Ok(value) => {
                                __protocol.bool_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct Insanity {
                    pub user_map:
                        ::std::option::Option<::std::collections::BTreeMap<Numberz, UserId>>,

                    pub xtructs: ::std::option::Option<::std::vec::Vec<Xtruct>>,
                }
                impl ::pilota::thrift::Message for Insanity {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "Insanity" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.user_map.as_ref() {
                            __protocol.write_btree_map_field(
                                1,
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::I64,
                                &value,
                                |__protocol, key| {
                                    __protocol.write_struct(key)?;
                                    ::std::result::Result::Ok(())
                                },
                                |__protocol, val| {
                                    __protocol.write_struct(val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.xtructs.as_ref() {
                            __protocol.write_list_field(
                                2,
                                ::pilota::thrift::TType::Struct,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_struct(val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_1 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val = ::std::collections::BTreeMap::new();
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    ::pilota::thrift::Message::decode(__protocol)?,
                                                    ::pilota::thrift::Message::decode(__protocol)?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_2 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<Xtruct> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write(
                                                    ::pilota::thrift::Message::decode(__protocol)?,
                                                );
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `Insanity` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            user_map: var_1,
                            xtructs: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_1 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::std::collections::BTreeMap::new();
                        for _ in 0..map_ident.size {
                            val.insert(<Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?, <UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_2 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(<Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `Insanity` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                user_map: var_1,
                                xtructs: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "Insanity",
                        }) + self.user_map.as_ref().map_or(0, |value| {
                            __protocol.btree_map_field_len(
                                Some(1),
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::I64,
                                value,
                                |__protocol, key| __protocol.struct_len(key),
                                |__protocol, val| __protocol.struct_len(val),
                            )
                        }) + self.xtructs.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(2),
                                ::pilota::thrift::TType::Struct,
                                value,
                                |__protocol, el| __protocol.struct_len(el),
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testTypedef("%d")' with thing as '%d'
                 * @param UserId thing - the UserId to print
                 * @return UserId - returns the UserId 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestTypedefResultSend {
                    fn default() -> Self {
                        ThriftTestTestTypedefResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestTypedefResultSend {
                    /**
                     * Prints 'testTypedef("%d")' with thing as '%d'
                     * @param UserId thing - the UserId to print
                     * @return UserId - returns the UserId 'thing'
                     */
                    Ok(UserId),
                }

                impl ::pilota::thrift::Message for ThriftTestTestTypedefResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestTypedefResultSend",
                        })?;
                        match self {
                            ThriftTestTestTypedefResultSend::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::I64,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret =
                                            Some(ThriftTestTestTypedefResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestTypedefResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestTypedefResultSend",
                        }) + match self {
                            ThriftTestTestTypedefResultSend::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
                 *  separated by commas and new lines
                 * @param map<string,string> thing - the map<string,string> to print
                 * @return map<string,string> - returns the map<string,string> 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestStringMapResultSend {
                    fn default() -> Self {
                        ThriftTestTestStringMapResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestStringMapResultSend {
                    /**
                     * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
                     *  separated by commas and new lines
                     * @param map<string,string> thing - the map<string,string> to print
                     * @return map<string,string> - returns the map<string,string> 'thing'
                     */
                    Ok(::pilota::AHashMap<::pilota::FastStr, ::pilota::FastStr>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestStringMapResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringMapResultSend",
                        })?;
                        match self {
                            ThriftTestTestStringMapResultSend::Ok(value) => {
                                __protocol.write_map_field(
                                    0,
                                    ::pilota::thrift::TType::Binary,
                                    ::pilota::thrift::TType::Binary,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_faststr((key).clone())?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_faststr((val).clone())?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_faststr()?,
                                                    __protocol.read_faststr()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::Binary,
                                            ::pilota::thrift::TType::Binary,
                                            &field_ident,
                                            |__protocol, key| __protocol.faststr_len(key),
                                            |__protocol, val| __protocol.faststr_len(val),
                                        );
                                        ret = Some(ThriftTestTestStringMapResultSend::Ok(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(
                                                        __protocol.read_faststr().await?,
                                                        __protocol.read_faststr().await?,
                                                    );
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret = Some(ThriftTestTestStringMapResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringMapResultSend",
                        }) + match self {
                            ThriftTestTestStringMapResultSend::Ok(value) => __protocol
                                .map_field_len(
                                    Some(0),
                                    ::pilota::thrift::TType::Binary,
                                    ::pilota::thrift::TType::Binary,
                                    value,
                                    |__protocol, key| __protocol.faststr_len(key),
                                    |__protocol, val| __protocol.faststr_len(val),
                                ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testException(%s)' with arg as '%s'
                 * @param string arg - a string indication what type of exception to throw
                 * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
                 * else if arg == "TException" throw TException
                 * else do not throw anything
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestExceptionArgsRecv {
                    pub arg: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for ThriftTestTestExceptionArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.arg).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestExceptionArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { arg: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestExceptionArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { arg: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionArgsRecv",
                        }) + __protocol.faststr_field_len(Some(1), &self.arg)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testUuid("%s")' where '%s' is the uuid given. Note that the uuid byte order should be correct.
                 * @param uuid  thing - the uuid to print
                 * @return uuid  - returns the uuid 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestUuidResultSend {
                    fn default() -> Self {
                        ThriftTestTestUuidResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestUuidResultSend {
                    /**
                     * Prints 'testUuid("%s")' where '%s' is the uuid given. Note that the uuid byte order should be correct.
                     * @param uuid  thing - the uuid to print
                     * @return uuid  - returns the uuid 'thing'
                     */
                    Ok([u8; 16]),
                }

                impl ::pilota::thrift::Message for ThriftTestTestUuidResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestUuidResultSend",
                        })?;
                        match self {
                            ThriftTestTestUuidResultSend::Ok(value) => {
                                __protocol.write_uuid_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_uuid()?;
                                        __protocol.uuid_len(*&field_ident);
                                        ret = Some(ThriftTestTestUuidResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_uuid().await?;

                                            ret =
                                                Some(ThriftTestTestUuidResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestUuidResultSend",
                        }) + match self {
                            ThriftTestTestUuidResultSend::Ok(value) => {
                                __protocol.uuid_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ListTypeVersioningV2 {
                    pub strings: ::std::option::Option<::std::vec::Vec<::pilota::FastStr>>,

                    pub hello: ::std::option::Option<::pilota::FastStr>,
                }
                impl ::pilota::thrift::Message for ListTypeVersioningV2 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ListTypeVersioningV2",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.strings.as_ref() {
                            __protocol.write_list_field(
                                1,
                                ::pilota::thrift::TType::Binary,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_faststr((val).clone())?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.hello.as_ref() {
                            __protocol.write_faststr_field(2, (value).clone())?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<::pilota::FastStr> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr()
                                                    .offset(i as isize)
                                                    .write(__protocol.read_faststr()?);
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_2 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ListTypeVersioningV2` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            strings: var_1,
                            hello: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_faststr().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_2 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ListTypeVersioningV2` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                strings: var_1,
                                hello: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ListTypeVersioningV2",
                        }) + self.strings.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(1),
                                ::pilota::thrift::TType::Binary,
                                value,
                                |__protocol, el| __protocol.faststr_len(el),
                            )
                        }) + self
                            .hello
                            .as_ref()
                            .map_or(0, |value| __protocol.faststr_field_len(Some(2), value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testI32("%d")' with thing as '%d'
                 * @param i32 thing - the i32 to print
                 * @return i32 - returns the i32 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestI32ResultSend {
                    fn default() -> Self {
                        ThriftTestTestI32ResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestI32ResultSend {
                    /**
                     * Prints 'testI32("%d")' with thing as '%d'
                     * @param i32 thing - the i32 to print
                     * @return i32 - returns the i32 'thing'
                     */
                    Ok(i32),
                }

                impl ::pilota::thrift::Message for ThriftTestTestI32ResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI32ResultSend",
                        })?;
                        match self {
                            ThriftTestTestI32ResultSend::Ok(value) => {
                                __protocol.write_i32_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_i32()?;
                                        __protocol.i32_len(*&field_ident);
                                        ret = Some(ThriftTestTestI32ResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_i32().await?;

                                            ret =
                                                Some(ThriftTestTestI32ResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI32ResultSend",
                        }) + match self {
                            ThriftTestTestI32ResultSend::Ok(value) => {
                                __protocol.i32_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints "testVoid()" and returns nothing.
                 */

                impl ::std::default::Default for ThriftTestTestVoidResultSend {
                    fn default() -> Self {
                        ThriftTestTestVoidResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestVoidResultSend {
                    /**
                     * Prints "testVoid()" and returns nothing.
                     */
                    Ok(()),
                }

                impl ::pilota::thrift::Message for ThriftTestTestVoidResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestVoidResultSend",
                        })?;
                        match self {
                            ThriftTestTestVoidResultSend::Ok(value) => {}
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Ok(ThriftTestTestVoidResultSend::Ok(()))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Ok(ThriftTestTestVoidResultSend::Ok(()))
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestVoidResultSend",
                        }) + match self {
                            ThriftTestTestVoidResultSend::Ok(value) => 0,
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * So you think you've got this all worked out, eh?
                 *
                 * Creates a map with these values and prints it out:
                 *   { 1 => { 2 => argument,
                 *            3 => argument,
                 *          },
                 *     2 => { 6 => <empty Insanity struct>, },
                 *   }
                 * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestInsanityArgsSend {
                    pub argument: Insanity,
                }
                impl ::pilota::thrift::Message for ThriftTestTestInsanityArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestInsanityArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_struct_field(
                            1,
                            &self.argument,
                            ::pilota::thrift::TType::Struct,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestInsanityArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field argument is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { argument: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<Insanity as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestInsanityArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field argument is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { argument: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestInsanityArgsSend",
                        }) + __protocol.struct_field_len(Some(1), &self.argument)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ListBonks {
                    pub bonk: ::std::option::Option<::std::vec::Vec<Bonk>>,
                }
                impl ::pilota::thrift::Message for ListBonks {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident =
                            ::pilota::thrift::TStructIdentifier { name: "ListBonks" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.bonk.as_ref() {
                            __protocol.write_list_field(
                                1,
                                ::pilota::thrift::TType::Struct,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_struct(val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<Bonk> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write(
                                                    ::pilota::thrift::Message::decode(__protocol)?,
                                                );
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `ListBonks` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self { bonk: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(<Bonk as ::pilota::thrift::Message>::decode_async(__protocol).await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ListBonks` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self { bonk: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ListBonks",
                        }) + self.bonk.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(1),
                                ::pilota::thrift::TType::Struct,
                                value,
                                |__protocol, el| __protocol.struct_len(el),
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testList("{%s}")' where thing has been formatted into a string of values
                 *  separated by commas and new lines
                 * @param list<i32> thing - the list<i32> to print
                 * @return list<i32> - returns the list<i32> 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestListArgsSend {
                    pub thing: ::std::vec::Vec<i32>,
                }
                impl ::pilota::thrift::Message for ThriftTestTestListArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestListArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_list_field(
                            1,
                            ::pilota::thrift::TType::I32,
                            &&self.thing,
                            |__protocol, val| {
                                __protocol.write_i32(*val)?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<i32> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr()
                                                    .offset(i as isize)
                                                    .write(__protocol.read_i32()?);
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestListArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_i32().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestListArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestListArgsSend",
                        }) + __protocol.list_field_len(
                            Some(1),
                            ::pilota::thrift::TType::I32,
                            &self.thing,
                            |__protocol, el| __protocol.i32_len(*el),
                        ) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
                 * sleep 'secondsToSleep'
                 * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
                 * @param i32 secondsToSleep - the number of seconds to sleep
                 */

                impl ::std::default::Default for ThriftTestTestOnewayResultRecv {
                    fn default() -> Self {
                        ThriftTestTestOnewayResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestOnewayResultRecv {
                    /**
                     * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
                     * sleep 'secondsToSleep'
                     * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
                     * @param i32 secondsToSleep - the number of seconds to sleep
                     */
                    Ok(()),
                }

                impl ::pilota::thrift::Message for ThriftTestTestOnewayResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestOnewayResultRecv",
                        })?;
                        match self {
                            ThriftTestTestOnewayResultRecv::Ok(value) => {}
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Ok(ThriftTestTestOnewayResultRecv::Ok(()))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Ok(ThriftTestTestOnewayResultRecv::Ok(()))
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestOnewayResultRecv",
                        }) + match self {
                            ThriftTestTestOnewayResultRecv::Ok(value) => 0,
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
                 * @param Xtruct2 thing - the Xtruct2 to print
                 * @return Xtruct2 - returns the Xtruct2 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestNestArgsSend {
                    pub thing: Xtruct2,
                }
                impl ::pilota::thrift::Message for ThriftTestTestNestArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestNestArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_struct_field(
                            1,
                            &self.thing,
                            ::pilota::thrift::TType::Struct,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestNestArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<Xtruct2 as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestNestArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestNestArgsSend",
                        }) + __protocol.struct_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMulti()'
                 * @param i8 arg0 -
                 * @param i32 arg1 -
                 * @param i64 arg2 -
                 * @param map<i16, string> arg3 -
                 * @param Numberz arg4 -
                 * @param UserId arg5 -
                 * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
                 *    and i64_thing = arg2
                 */
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestMultiArgsRecv {
                    pub arg0: i8,

                    pub arg1: i32,

                    pub arg2: i64,

                    pub arg3: ::pilota::AHashMap<i16, ::pilota::FastStr>,

                    pub arg4: Numberz,

                    pub arg5: UserId,
                }
                impl ::pilota::thrift::Message for ThriftTestTestMultiArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i8_field(1, *&self.arg0)?;
                        __protocol.write_i32_field(2, *&self.arg1)?;
                        __protocol.write_i64_field(3, *&self.arg2)?;
                        __protocol.write_map_field(
                            4,
                            ::pilota::thrift::TType::I16,
                            ::pilota::thrift::TType::Binary,
                            &&self.arg3,
                            |__protocol, key| {
                                __protocol.write_i16(*key)?;
                                ::std::result::Result::Ok(())
                            },
                            |__protocol, val| {
                                __protocol.write_faststr((val).clone())?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_i32_field(5, (&self.arg4).inner())?;
                        __protocol.write_struct_field(
                            6,
                            &self.arg5,
                            ::pilota::thrift::TType::I64,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;
                        let mut var_3 = None;
                        let mut var_4 = None;
                        let mut var_5 = None;
                        let mut var_6 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I8 =>
                                    {
                                        var_1 = Some(__protocol.read_i8()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_2 = Some(__protocol.read_i32()?);
                                    }
                                    Some(3)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_3 = Some(__protocol.read_i64()?);
                                    }
                                    Some(4)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_4 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_i16()?,
                                                    __protocol.read_faststr()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    Some(5)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_5 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(6)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_6 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestMultiArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg0 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_2) = var_2 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg1 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_3) = var_3 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg2 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_4) = var_4 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg3 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_5) = var_5 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg4 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_6) = var_6 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg5 is required".to_string(),
                                ),
                            );
                        };

                        let data = Self {
                            arg0: var_1,
                            arg1: var_2,
                            arg2: var_3,
                            arg3: var_4,
                            arg4: var_5,
                            arg5: var_6,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;
                            let mut var_3 = None;
                            let mut var_4 = None;
                            let mut var_5 = None;
                            let mut var_6 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I8  => {
                    var_1 = Some(__protocol.read_i8().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_2 = Some(__protocol.read_i32().await?);

                },Some(3) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_3 = Some(__protocol.read_i64().await?);

                },Some(4) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_4 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i16().await?, __protocol.read_faststr().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },Some(5) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_5 = Some(<Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(6) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_6 = Some(<UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestMultiArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg0 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_2) = var_2 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg1 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_3) = var_3 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg2 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_4) = var_4 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg3 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_5) = var_5 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg4 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_6) = var_6 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg5 is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self {
                                arg0: var_1,
                                arg1: var_2,
                                arg2: var_3,
                                arg3: var_4,
                                arg4: var_5,
                                arg5: var_6,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiArgsRecv",
                        }) + __protocol.i8_field_len(Some(1), *&self.arg0)
                            + __protocol.i32_field_len(Some(2), *&self.arg1)
                            + __protocol.i64_field_len(Some(3), *&self.arg2)
                            + __protocol.map_field_len(
                                Some(4),
                                ::pilota::thrift::TType::I16,
                                ::pilota::thrift::TType::Binary,
                                &self.arg3,
                                |__protocol, key| __protocol.i16_len(*key),
                                |__protocol, val| __protocol.faststr_len(val),
                            )
                            + __protocol.i32_field_len(Some(5), (&self.arg4).inner())
                            + __protocol.struct_field_len(Some(6), &self.arg5)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct Xtruct {
                    pub string_thing: ::std::option::Option<::pilota::FastStr>,

                    pub byte_thing: ::std::option::Option<i8>,

                    pub i32_thing: ::std::option::Option<i32>,

                    pub i64_thing: ::std::option::Option<i64>,
                }
                impl ::pilota::thrift::Message for Xtruct {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "Xtruct" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.string_thing.as_ref() {
                            __protocol.write_faststr_field(1, (value).clone())?;
                        }
                        if let Some(value) = self.byte_thing.as_ref() {
                            __protocol.write_i8_field(4, *value)?;
                        }
                        if let Some(value) = self.i32_thing.as_ref() {
                            __protocol.write_i32_field(9, *value)?;
                        }
                        if let Some(value) = self.i64_thing.as_ref() {
                            __protocol.write_i64_field(11, *value)?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_4 = None;
                        let mut var_9 = None;
                        let mut var_11 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    Some(4)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I8 =>
                                    {
                                        var_4 = Some(__protocol.read_i8()?);
                                    }
                                    Some(9)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_9 = Some(__protocol.read_i32()?);
                                    }
                                    Some(11)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_11 = Some(__protocol.read_i64()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `Xtruct` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            string_thing: var_1,
                            byte_thing: var_4,
                            i32_thing: var_9,
                            i64_thing: var_11,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_4 = None;
                            let mut var_9 = None;
                            let mut var_11 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },Some(4) if field_ident.field_type == ::pilota::thrift::TType::I8  => {
                    var_4 = Some(__protocol.read_i8().await?);

                },Some(9) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_9 = Some(__protocol.read_i32().await?);

                },Some(11) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_11 = Some(__protocol.read_i64().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `Xtruct` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                string_thing: var_1,
                                byte_thing: var_4,
                                i32_thing: var_9,
                                i64_thing: var_11,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "Xtruct",
                        }) + self
                            .string_thing
                            .as_ref()
                            .map_or(0, |value| __protocol.faststr_field_len(Some(1), value))
                            + self
                                .byte_thing
                                .as_ref()
                                .map_or(0, |value| __protocol.i8_field_len(Some(4), *value))
                            + self
                                .i32_thing
                                .as_ref()
                                .map_or(0, |value| __protocol.i32_field_len(Some(9), *value))
                            + self
                                .i64_thing
                                .as_ref()
                                .map_or(0, |value| __protocol.i64_field_len(Some(11), *value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testDouble("%f")' with thing as '%f'
                 * @param double thing - the double to print
                 * @return double - returns the double 'thing'
                 */
                #[derive(PartialOrd, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestDoubleArgsSend {
                    pub thing: f64,
                }
                impl ::pilota::thrift::Message for ThriftTestTestDoubleArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestDoubleArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_double_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Double =>
                                    {
                                        var_1 = Some(__protocol.read_double()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestDoubleArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Double  => {
                    var_1 = Some(__protocol.read_double().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestDoubleArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestDoubleArgsSend",
                        }) + __protocol.double_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
                 * @param Numberz thing - the Numberz to print
                 * @return Numberz - returns the Numberz 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestEnumArgsRecv {
                    pub thing: Numberz,
                }
                impl ::pilota::thrift::Message for ThriftTestTestEnumArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestEnumArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i32_field(1, (&self.thing).inner())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestEnumArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(<Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestEnumArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestEnumArgsRecv",
                        }) + __protocol.i32_field_len(Some(1), (&self.thing).inner())
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testString("%s")' with thing as '%s'
                 * @param string thing - the string to print
                 * @return string - returns the string 'thing'
                 */

                impl ::std::default::Default for SecondServiceSecondtestStringResultRecv {
                    fn default() -> Self {
                        SecondServiceSecondtestStringResultRecv::Ok(
                            ::std::default::Default::default(),
                        )
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum SecondServiceSecondtestStringResultRecv {
                    /**
                     * Prints 'testString("%s")' with thing as '%s'
                     * @param string thing - the string to print
                     * @return string - returns the string 'thing'
                     */
                    Ok(::pilota::FastStr),
                }

                impl ::pilota::thrift::Message for SecondServiceSecondtestStringResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "SecondServiceSecondtestStringResultRecv",
                        })?;
                        match self {
                            SecondServiceSecondtestStringResultRecv::Ok(value) => {
                                __protocol.write_faststr_field(0, (value).clone())?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_faststr()?;
                                        __protocol.faststr_len(&field_ident);
                                        ret = Some(SecondServiceSecondtestStringResultRecv::Ok(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_faststr().await?;

                                            ret =
                                                Some(SecondServiceSecondtestStringResultRecv::Ok(
                                                    field_ident,
                                                ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "SecondServiceSecondtestStringResultRecv",
                        }) + match self {
                            SecondServiceSecondtestStringResultRecv::Ok(value) => {
                                __protocol.faststr_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
                 * @param bool  thing - the bool data to print
                 * @return bool  - returns the bool 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestBoolArgsSend {
                    pub thing: bool,
                }
                impl ::pilota::thrift::Message for ThriftTestTestBoolArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBoolArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_bool_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Bool =>
                                    {
                                        var_1 = Some(__protocol.read_bool()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestBoolArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Bool  => {
                    var_1 = Some(__protocol.read_bool().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestBoolArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBoolArgsSend",
                        }) + __protocol.bool_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
                 *  separated by commas and new lines
                 * @param map<i32,i32> thing - the map<i32,i32> to print
                 * @return map<i32,i32> - returns the map<i32,i32> 'thing'
                 */
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestMapArgsRecv {
                    pub thing: ::pilota::AHashMap<i32, i32>,
                }
                impl ::pilota::thrift::Message for ThriftTestTestMapArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_map_field(
                            1,
                            ::pilota::thrift::TType::I32,
                            ::pilota::thrift::TType::I32,
                            &&self.thing,
                            |__protocol, key| {
                                __protocol.write_i32(*key)?;
                                ::std::result::Result::Ok(())
                            },
                            |__protocol, val| {
                                __protocol.write_i32(*val)?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_1 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_i32()?,
                                                    __protocol.read_i32()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestMapArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_1 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i32().await?, __protocol.read_i32().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestMapArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapArgsRecv",
                        }) + __protocol.map_field_len(
                            Some(1),
                            ::pilota::thrift::TType::I32,
                            ::pilota::thrift::TType::I32,
                            &self.thing,
                            |__protocol, key| __protocol.i32_len(*key),
                            |__protocol, val| __protocol.i32_len(*val),
                        ) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testException(%s)' with arg as '%s'
                 * @param string arg - a string indication what type of exception to throw
                 * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
                 * else if arg == "TException" throw TException
                 * else do not throw anything
                 */

                impl ::std::default::Default for ThriftTestTestExceptionException {
                    fn default() -> Self {
                        ThriftTestTestExceptionException::Err1(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestExceptionException {
                    Err1(Xception),
                }

                impl ::pilota::thrift::Message for ThriftTestTestExceptionException {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionException",
                        })?;
                        match self {
                            ThriftTestTestExceptionException::Err1(value) => {
                                __protocol.write_struct_field(
                                    1,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(1) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestExceptionException::Err1(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(1) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestExceptionException::Err1(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionException",
                        }) + match self {
                            ThriftTestTestExceptionException::Err1(value) => {
                                __protocol.struct_field_len(Some(1), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
                 * @param binary  thing - the binary data to print
                 * @return binary  - returns the binary 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestBinaryArgsRecv {
                    pub thing: ::pilota::Bytes,
                }
                impl ::pilota::thrift::Message for ThriftTestTestBinaryArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBinaryArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_bytes_field(1, (&self.thing).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_bytes()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestBinaryArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_bytes().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestBinaryArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBinaryArgsRecv",
                        }) + __protocol.bytes_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMapMap("%d")' with hello as '%d'
                 * @param i32 hello - the i32 to print
                 * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
                 *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
                 */

                impl ::std::default::Default for ThriftTestTestMapMapResultRecv {
                    fn default() -> Self {
                        ThriftTestTestMapMapResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMapMapResultRecv {
                    /**
                     * Prints 'testMapMap("%d")' with hello as '%d'
                     * @param i32 hello - the i32 to print
                     * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
                     *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
                     */
                    Ok(::pilota::AHashMap<i32, ::pilota::AHashMap<i32, i32>>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMapMapResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapMapResultRecv",
                        })?;
                        match self {
                            ThriftTestTestMapMapResultRecv::Ok(value) => {
                                __protocol.write_map_field(
                                    0,
                                    ::pilota::thrift::TType::I32,
                                    ::pilota::thrift::TType::Map,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_i32(*key)?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_map(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::I32,
                                            &val,
                                            |__protocol, key| {
                                                __protocol.write_i32(*key)?;
                                                ::std::result::Result::Ok(())
                                            },
                                            |__protocol, val| {
                                                __protocol.write_i32(*val)?;
                                                ::std::result::Result::Ok(())
                                            },
                                        )?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(__protocol.read_i32()?, {
                                                    let map_ident = __protocol.read_map_begin()?;
                                                    let mut val = ::pilota::AHashMap::with_capacity(
                                                        map_ident.size,
                                                    );
                                                    for _ in 0..map_ident.size {
                                                        val.insert(
                                                            __protocol.read_i32()?,
                                                            __protocol.read_i32()?,
                                                        );
                                                    }
                                                    __protocol.read_map_end()?;
                                                    val
                                                });
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::Map,
                                            &field_ident,
                                            |__protocol, key| __protocol.i32_len(*key),
                                            |__protocol, val| {
                                                __protocol.map_len(
                                                    ::pilota::thrift::TType::I32,
                                                    ::pilota::thrift::TType::I32,
                                                    val,
                                                    |__protocol, key| __protocol.i32_len(*key),
                                                    |__protocol, val| __protocol.i32_len(*val),
                                                )
                                            },
                                        );
                                        ret = Some(ThriftTestTestMapMapResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(__protocol.read_i32().await?, {
                                                        let map_ident =
                                                            __protocol.read_map_begin().await?;
                                                        let mut val =
                                                            ::pilota::AHashMap::with_capacity(
                                                                map_ident.size,
                                                            );
                                                        for _ in 0..map_ident.size {
                                                            val.insert(
                                                                __protocol.read_i32().await?,
                                                                __protocol.read_i32().await?,
                                                            );
                                                        }
                                                        __protocol.read_map_end().await?;
                                                        val
                                                    });
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret = Some(ThriftTestTestMapMapResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapMapResultRecv",
                        }) + match self {
                            ThriftTestTestMapMapResultRecv::Ok(value) => __protocol.map_field_len(
                                Some(0),
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::Map,
                                value,
                                |__protocol, key| __protocol.i32_len(*key),
                                |__protocol, val| {
                                    __protocol.map_len(
                                        ::pilota::thrift::TType::I32,
                                        ::pilota::thrift::TType::I32,
                                        val,
                                        |__protocol, key| __protocol.i32_len(*key),
                                        |__protocol, val| __protocol.i32_len(*val),
                                    )
                                },
                            ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct VersioningTestV1 {
                    pub begin_in_both: ::std::option::Option<i32>,

                    pub old_string: ::std::option::Option<::pilota::FastStr>,

                    pub end_in_both: ::std::option::Option<i32>,
                }
                impl ::pilota::thrift::Message for VersioningTestV1 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "VersioningTestV1",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.begin_in_both.as_ref() {
                            __protocol.write_i32_field(1, *value)?;
                        }
                        if let Some(value) = self.old_string.as_ref() {
                            __protocol.write_faststr_field(3, (value).clone())?;
                        }
                        if let Some(value) = self.end_in_both.as_ref() {
                            __protocol.write_i32_field(12, *value)?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_3 = None;
                        let mut var_12 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    Some(3)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_3 = Some(__protocol.read_faststr()?);
                                    }
                                    Some(12)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_12 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `VersioningTestV1` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            begin_in_both: var_1,
                            old_string: var_3,
                            end_in_both: var_12,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_3 = None;
                            let mut var_12 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },Some(3) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_3 = Some(__protocol.read_faststr().await?);

                },Some(12) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_12 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `VersioningTestV1` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                begin_in_both: var_1,
                                old_string: var_3,
                                end_in_both: var_12,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "VersioningTestV1",
                        }) + self
                            .begin_in_both
                            .as_ref()
                            .map_or(0, |value| __protocol.i32_field_len(Some(1), *value))
                            + self
                                .old_string
                                .as_ref()
                                .map_or(0, |value| __protocol.faststr_field_len(Some(3), value))
                            + self
                                .end_in_both
                                .as_ref()
                                .map_or(0, |value| __protocol.i32_field_len(Some(12), *value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testByte("%d")' with thing as '%d'
                 * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
                 * @param byte thing - the i8/byte to print
                 * @return i8 - returns the i8/byte 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestByteArgsRecv {
                    pub thing: i8,
                }
                impl ::pilota::thrift::Message for ThriftTestTestByteArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestByteArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i8_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I8 =>
                                    {
                                        var_1 = Some(__protocol.read_i8()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestByteArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I8  => {
                    var_1 = Some(__protocol.read_i8().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestByteArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestByteArgsRecv",
                        }) + __protocol.i8_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
                 *  separated by commas and new lines
                 * @param set<i32> thing - the set<i32> to print
                 * @return set<i32> - returns the set<i32> 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestSetResultRecv {
                    fn default() -> Self {
                        ThriftTestTestSetResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestSetResultRecv {
                    /**
                     * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
                     *  separated by commas and new lines
                     * @param set<i32> thing - the set<i32> to print
                     * @return set<i32> - returns the set<i32> 'thing'
                     */
                    Ok(::pilota::AHashSet<i32>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestSetResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestSetResultRecv",
                        })?;
                        match self {
                            ThriftTestTestSetResultRecv::Ok(value) => {
                                __protocol.write_set_field(
                                    0,
                                    ::pilota::thrift::TType::I32,
                                    &value,
                                    |__protocol, val| {
                                        __protocol.write_i32(*val)?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let list_ident = __protocol.read_set_begin()?;
                                            let mut val =
                                                ::pilota::AHashSet::with_capacity(list_ident.size);
                                            for _ in 0..list_ident.size {
                                                val.insert(__protocol.read_i32()?);
                                            }
                                            __protocol.read_set_end()?;
                                            val
                                        };
                                        __protocol.set_len(
                                            ::pilota::thrift::TType::I32,
                                            &field_ident,
                                            |__protocol, el| __protocol.i32_len(*el),
                                        );
                                        ret = Some(ThriftTestTestSetResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let list_ident =
                                                    __protocol.read_set_begin().await?;
                                                let mut val = ::pilota::AHashSet::with_capacity(
                                                    list_ident.size,
                                                );
                                                for _ in 0..list_ident.size {
                                                    val.insert(__protocol.read_i32().await?);
                                                }
                                                __protocol.read_set_end().await?;
                                                val
                                            };

                                            ret =
                                                Some(ThriftTestTestSetResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestSetResultRecv",
                        }) + match self {
                            ThriftTestTestSetResultRecv::Ok(value) => __protocol.set_field_len(
                                Some(0),
                                ::pilota::thrift::TType::I32,
                                value,
                                |__protocol, el| __protocol.i32_len(*el),
                            ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct OneField {
                    pub field: ::std::option::Option<EmptyStruct>,
                }
                impl ::pilota::thrift::Message for OneField {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "OneField" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.field.as_ref() {
                            __protocol.write_struct_field(
                                1,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `OneField` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self { field: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<EmptyStruct as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `OneField` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self { field: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "OneField",
                        }) + self
                            .field
                            .as_ref()
                            .map_or(0, |value| __protocol.struct_field_len(Some(1), value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
                 * @param Xtruct thing - the Xtruct to print
                 * @return Xtruct - returns the Xtruct 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestStructResultRecv {
                    fn default() -> Self {
                        ThriftTestTestStructResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestStructResultRecv {
                    /**
                     * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
                     * @param Xtruct thing - the Xtruct to print
                     * @return Xtruct - returns the Xtruct 'thing'
                     */
                    Ok(Xtruct),
                }

                impl ::pilota::thrift::Message for ThriftTestTestStructResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStructResultRecv",
                        })?;
                        match self {
                            ThriftTestTestStructResultRecv::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestStructResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestStructResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStructResultRecv",
                        }) + match self {
                            ThriftTestTestStructResultRecv::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct NestedListsI32x3 {
                    pub integerlist: ::std::option::Option<
                        ::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<i32>>>,
                    >,
                }
                impl ::pilota::thrift::Message for NestedListsI32x3 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "NestedListsI32x3",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.integerlist.as_ref() {
                            __protocol.write_list_field(
                                1,
                                ::pilota::thrift::TType::List,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_list(
                                        ::pilota::thrift::TType::List,
                                        &val,
                                        |__protocol, val| {
                                            __protocol.write_list(
                                                ::pilota::thrift::TType::I32,
                                                &val,
                                                |__protocol, val| {
                                                    __protocol.write_i32(*val)?;
                                                    ::std::result::Result::Ok(())
                                                },
                                            )?;
                                            ::std::result::Result::Ok(())
                                        },
                                    )?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<
                                                ::std::vec::Vec<::std::vec::Vec<i32>>,
                                            > = ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write(unsafe {
                                                    let list_ident =
                                                        __protocol.read_list_begin()?;
                                                    let mut val: ::std::vec::Vec<
                                                        ::std::vec::Vec<i32>,
                                                    > = ::std::vec::Vec::with_capacity(
                                                        list_ident.size,
                                                    );
                                                    for i in 0..list_ident.size {
                                                        val.as_mut_ptr().offset(i as isize).write(
                                                            unsafe {
                                                                let list_ident =
                                                                    __protocol.read_list_begin()?;
                                                                let mut val: ::std::vec::Vec<i32> =
                                                                    ::std::vec::Vec::with_capacity(
                                                                        list_ident.size,
                                                                    );
                                                                for i in 0..list_ident.size {
                                                                    val.as_mut_ptr()
                                                                        .offset(i as isize)
                                                                        .write(
                                                                            __protocol
                                                                                .read_i32()?,
                                                                        );
                                                                }
                                                                val.set_len(list_ident.size);
                                                                __protocol.read_list_end()?;
                                                                val
                                                            },
                                                        );
                                                    }
                                                    val.set_len(list_ident.size);
                                                    __protocol.read_list_end()?;
                                                    val
                                                });
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `NestedListsI32x3` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self { integerlist: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_i32().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `NestedListsI32x3` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self { integerlist: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "NestedListsI32x3",
                        }) + self.integerlist.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(1),
                                ::pilota::thrift::TType::List,
                                value,
                                |__protocol, el| {
                                    __protocol.list_len(
                                        ::pilota::thrift::TType::List,
                                        el,
                                        |__protocol, el| {
                                            __protocol.list_len(
                                                ::pilota::thrift::TType::I32,
                                                el,
                                                |__protocol, el| __protocol.i32_len(*el),
                                            )
                                        },
                                    )
                                },
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testI64("%d")' with thing as '%d'
                 * @param i64 thing - the i64 to print
                 * @return i64 - returns the i64 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestI64ResultRecv {
                    fn default() -> Self {
                        ThriftTestTestI64ResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestI64ResultRecv {
                    /**
                     * Prints 'testI64("%d")' with thing as '%d'
                     * @param i64 thing - the i64 to print
                     * @return i64 - returns the i64 'thing'
                     */
                    Ok(i64),
                }

                impl ::pilota::thrift::Message for ThriftTestTestI64ResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI64ResultRecv",
                        })?;
                        match self {
                            ThriftTestTestI64ResultRecv::Ok(value) => {
                                __protocol.write_i64_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_i64()?;
                                        __protocol.i64_len(*&field_ident);
                                        ret = Some(ThriftTestTestI64ResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_i64().await?;

                                            ret =
                                                Some(ThriftTestTestI64ResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI64ResultRecv",
                        }) + match self {
                            ThriftTestTestI64ResultRecv::Ok(value) => {
                                __protocol.i64_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testString("%s")' with thing as '%s'
                 * @param string thing - the string to print
                 * @return string - returns the string 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestStringResultRecv {
                    fn default() -> Self {
                        ThriftTestTestStringResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestStringResultRecv {
                    /**
                     * Prints 'testString("%s")' with thing as '%s'
                     * @param string thing - the string to print
                     * @return string - returns the string 'thing'
                     */
                    Ok(::pilota::FastStr),
                }

                impl ::pilota::thrift::Message for ThriftTestTestStringResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringResultRecv",
                        })?;
                        match self {
                            ThriftTestTestStringResultRecv::Ok(value) => {
                                __protocol.write_faststr_field(0, (value).clone())?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_faststr()?;
                                        __protocol.faststr_len(&field_ident);
                                        ret = Some(ThriftTestTestStringResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_faststr().await?;

                                            ret = Some(ThriftTestTestStringResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringResultRecv",
                        }) + match self {
                            ThriftTestTestStringResultRecv::Ok(value) => {
                                __protocol.faststr_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMulti()'
                 * @param i8 arg0 -
                 * @param i32 arg1 -
                 * @param i64 arg2 -
                 * @param map<i16, string> arg3 -
                 * @param Numberz arg4 -
                 * @param UserId arg5 -
                 * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
                 *    and i64_thing = arg2
                 */

                impl ::std::default::Default for ThriftTestTestMultiResultSend {
                    fn default() -> Self {
                        ThriftTestTestMultiResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMultiResultSend {
                    /**
                     * Prints 'testMulti()'
                     * @param i8 arg0 -
                     * @param i32 arg1 -
                     * @param i64 arg2 -
                     * @param map<i16, string> arg3 -
                     * @param Numberz arg4 -
                     * @param UserId arg5 -
                     * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
                     *    and i64_thing = arg2
                     */
                    Ok(Xtruct),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMultiResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiResultSend",
                        })?;
                        match self {
                            ThriftTestTestMultiResultSend::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestMultiResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiResultSend",
                        }) + match self {
                            ThriftTestTestMultiResultSend::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct Bonk {
                    pub message: ::std::option::Option<::pilota::FastStr>,

                    pub r#type: ::std::option::Option<i32>,
                }
                impl ::pilota::thrift::Message for Bonk {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "Bonk" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.message.as_ref() {
                            __protocol.write_faststr_field(1, (value).clone())?;
                        }
                        if let Some(value) = self.r#type.as_ref() {
                            __protocol.write_i32_field(2, *value)?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_2 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `Bonk` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            message: var_1,
                            r#type: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_2 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `Bonk` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                message: var_1,
                                r#type: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol
                            .struct_begin_len(&::pilota::thrift::TStructIdentifier { name: "Bonk" })
                            + self
                                .message
                                .as_ref()
                                .map_or(0, |value| __protocol.faststr_field_len(Some(1), value))
                            + self
                                .r#type
                                .as_ref()
                                .map_or(0, |value| __protocol.i32_field_len(Some(2), *value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct StructB {
                    pub aa: ::std::option::Option<StructA>,

                    pub ab: StructA,
                }
                impl ::pilota::thrift::Message for StructB {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "StructB" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.aa.as_ref() {
                            __protocol.write_struct_field(
                                1,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        __protocol.write_struct_field(
                            2,
                            &self.ab,
                            ::pilota::thrift::TType::Struct,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_2 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `StructB` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_2) = var_2 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field ab is required".to_string(),
                                ),
                            );
                        };

                        let data = Self {
                            aa: var_1,
                            ab: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<StructA as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_2 = Some(<StructA as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `StructB` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_2) = var_2 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field ab is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self {
                                aa: var_1,
                                ab: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "StructB",
                        }) + self
                            .aa
                            .as_ref()
                            .map_or(0, |value| __protocol.struct_field_len(Some(1), value))
                            + __protocol.struct_field_len(Some(2), &self.ab)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
                 * @param Numberz thing - the Numberz to print
                 * @return Numberz - returns the Numberz 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestEnumResultSend {
                    fn default() -> Self {
                        ThriftTestTestEnumResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestEnumResultSend {
                    /**
                     * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
                     * @param Numberz thing - the Numberz to print
                     * @return Numberz - returns the Numberz 'thing'
                     */
                    Ok(Numberz),
                }

                impl ::pilota::thrift::Message for ThriftTestTestEnumResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestEnumResultSend",
                        })?;
                        match self {
                            ThriftTestTestEnumResultSend::Ok(value) => {
                                __protocol.write_i32_field(0, (value).inner())?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestEnumResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestEnumResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestEnumResultSend",
                        }) + match self {
                            ThriftTestTestEnumResultSend::Ok(value) => {
                                __protocol.i32_field_len(Some(0), (value).inner())
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
                 * sleep 'secondsToSleep'
                 * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
                 * @param i32 secondsToSleep - the number of seconds to sleep
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestOnewayArgsSend {
                    pub seconds_to_sleep: i32,
                }
                impl ::pilota::thrift::Message for ThriftTestTestOnewayArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestOnewayArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i32_field(1, *&self.seconds_to_sleep)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestOnewayArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field seconds_to_sleep is required".to_string(),
                                ),
                            );
                        };

                        let data = Self {
                            seconds_to_sleep: var_1,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestOnewayArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field seconds_to_sleep is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self {
                                seconds_to_sleep: var_1,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestOnewayArgsSend",
                        }) + __protocol.i32_field_len(Some(1), *&self.seconds_to_sleep)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
                 *  separated by commas and new lines
                 * @param map<i32,i32> thing - the map<i32,i32> to print
                 * @return map<i32,i32> - returns the map<i32,i32> 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestMapResultSend {
                    fn default() -> Self {
                        ThriftTestTestMapResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMapResultSend {
                    /**
                     * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
                     *  separated by commas and new lines
                     * @param map<i32,i32> thing - the map<i32,i32> to print
                     * @return map<i32,i32> - returns the map<i32,i32> 'thing'
                     */
                    Ok(::pilota::AHashMap<i32, i32>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMapResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapResultSend",
                        })?;
                        match self {
                            ThriftTestTestMapResultSend::Ok(value) => {
                                __protocol.write_map_field(
                                    0,
                                    ::pilota::thrift::TType::I32,
                                    ::pilota::thrift::TType::I32,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_i32(*key)?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_i32(*val)?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_i32()?,
                                                    __protocol.read_i32()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::I32,
                                            &field_ident,
                                            |__protocol, key| __protocol.i32_len(*key),
                                            |__protocol, val| __protocol.i32_len(*val),
                                        );
                                        ret = Some(ThriftTestTestMapResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(
                                                        __protocol.read_i32().await?,
                                                        __protocol.read_i32().await?,
                                                    );
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret =
                                                Some(ThriftTestTestMapResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapResultSend",
                        }) + match self {
                            ThriftTestTestMapResultSend::Ok(value) => __protocol.map_field_len(
                                Some(0),
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::I32,
                                value,
                                |__protocol, key| __protocol.i32_len(*key),
                                |__protocol, val| __protocol.i32_len(*val),
                            ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testException(%s)' with arg as '%s'
                 * @param string arg - a string indication what type of exception to throw
                 * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
                 * else if arg == "TException" throw TException
                 * else do not throw anything
                 */

                impl ::std::default::Default for ThriftTestTestExceptionResultSend {
                    fn default() -> Self {
                        ThriftTestTestExceptionResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestExceptionResultSend {
                    /**
                     * Print 'testException(%s)' with arg as '%s'
                     * @param string arg - a string indication what type of exception to throw
                     * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
                     * else if arg == "TException" throw TException
                     * else do not throw anything
                     */
                    Ok(()),

                    Err1(Xception),
                }

                impl ::pilota::thrift::Message for ThriftTestTestExceptionResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionResultSend",
                        })?;
                        match self {
                            ThriftTestTestExceptionResultSend::Ok(value) => {}
                            ThriftTestTestExceptionResultSend::Err1(value) => {
                                __protocol.write_struct_field(
                                    1,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(1) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestExceptionResultSend::Err1(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Ok(ThriftTestTestExceptionResultSend::Ok(()))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(1) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestExceptionResultSend::Err1(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Ok(ThriftTestTestExceptionResultSend::Ok(()))
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionResultSend",
                        }) + match self {
                            ThriftTestTestExceptionResultSend::Ok(value) => 0,
                            ThriftTestTestExceptionResultSend::Err1(value) => {
                                __protocol.struct_field_len(Some(1), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct CrazyNesting {
                    pub string_field: ::std::option::Option<::pilota::FastStr>,

                    pub set_field: ::std::option::Option<::pilota::AHashSet<Insanity>>,

                    // Do not insert line break as test/go/Makefile.am is removing this line with pattern match
                    pub list_field: ::std::vec::Vec<
                        ::std::collections::BTreeMap<
                            ::std::collections::BTreeSet<i32>,
                            ::std::collections::BTreeMap<
                                i32,
                                ::std::collections::BTreeSet<
                                    ::std::vec::Vec<
                                        ::std::collections::BTreeMap<Insanity, ::pilota::FastStr>,
                                    >,
                                >,
                            >,
                        >,
                    >,

                    pub binary_field: ::std::option::Option<::pilota::Bytes>,

                    pub uuid_field: ::std::option::Option<[u8; 16]>,
                }
                impl ::pilota::thrift::Message for CrazyNesting {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "CrazyNesting",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.string_field.as_ref() {
                            __protocol.write_faststr_field(1, (value).clone())?;
                        }
                        if let Some(value) = self.set_field.as_ref() {
                            __protocol.write_set_field(
                                2,
                                ::pilota::thrift::TType::Struct,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_struct(val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_list_field(3, ::pilota::thrift::TType::Map, &&self.list_field, |__protocol, val| {
                        __protocol.write_btree_map(::pilota::thrift::TType::Set, ::pilota::thrift::TType::Map, &val, |__protocol, key| {
                __protocol.write_btree_set(::pilota::thrift::TType::I32, &key, |__protocol, val| {
                __protocol.write_i32(*val)?;
                ::std::result::Result::Ok(())
            })?;
                ::std::result::Result::Ok(())
            }, |__protocol, val| {
                __protocol.write_btree_map(::pilota::thrift::TType::I32, ::pilota::thrift::TType::Set, &val, |__protocol, key| {
                __protocol.write_i32(*key)?;
                ::std::result::Result::Ok(())
            }, |__protocol, val| {
                __protocol.write_btree_set(::pilota::thrift::TType::List, &val, |__protocol, val| {
                __protocol.write_list(::pilota::thrift::TType::Map, &val, |__protocol, val| {
                        __protocol.write_btree_map(::pilota::thrift::TType::Struct, ::pilota::thrift::TType::Binary, &val, |__protocol, key| {
                __protocol.write_struct(key)?;
                ::std::result::Result::Ok(())
            }, |__protocol, val| {
                __protocol.write_faststr((val).clone())?;
                ::std::result::Result::Ok(())
            })?;
                        ::std::result::Result::Ok(())
                    })?;
                ::std::result::Result::Ok(())
            })?;
                ::std::result::Result::Ok(())
            })?;
                ::std::result::Result::Ok(())
            })?;
                        ::std::result::Result::Ok(())
                    })?;
                        if let Some(value) = self.binary_field.as_ref() {
                            __protocol.write_bytes_field(4, (value).clone())?;
                        }
                        if let Some(value) = self.uuid_field.as_ref() {
                            __protocol.write_uuid_field(5, *value)?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;
                        let mut var_3 = None;
                        let mut var_4 = None;
                        let mut var_5 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Set =>
                                    {
                                        var_2 = Some({
                                            let list_ident = __protocol.read_set_begin()?;
                                            let mut val =
                                                ::pilota::AHashSet::with_capacity(list_ident.size);
                                            for _ in 0..list_ident.size {
                                                val.insert(::pilota::thrift::Message::decode(
                                                    __protocol,
                                                )?);
                                            }
                                            __protocol.read_set_end()?;
                                            val
                                        });
                                    }
                                    Some(3)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_3 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<
                                                ::std::collections::BTreeMap<
                                                    ::std::collections::BTreeSet<i32>,
                                                    ::std::collections::BTreeMap<
                                                        i32,
                                                        ::std::collections::BTreeSet<
                                                            ::std::vec::Vec<
                                                                ::std::collections::BTreeMap<
                                                                    Insanity,
                                                                    ::pilota::FastStr,
                                                                >,
                                                            >,
                                                        >,
                                                    >,
                                                >,
                                            > = ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write({
                        let map_ident = __protocol.read_map_begin()?;
                        let mut val = ::std::collections::BTreeMap::new();
                        for _ in 0..map_ident.size {
                            val.insert({let list_ident = __protocol.read_set_begin()?;
                    let mut val = ::std::collections::BTreeSet::new();
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_i32()?);
                    };
                    __protocol.read_set_end()?;
                    val}, {
                        let map_ident = __protocol.read_map_begin()?;
                        let mut val = ::std::collections::BTreeMap::new();
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i32()?, {let list_ident = __protocol.read_set_begin()?;
                    let mut val = ::std::collections::BTreeSet::new();
                    for _ in 0..list_ident.size {
                        val.insert(unsafe {
                            let list_ident = __protocol.read_list_begin()?;
                            let mut val: ::std::vec::Vec<::std::collections::BTreeMap<Insanity, ::pilota::FastStr>> = ::std::vec::Vec::with_capacity(list_ident.size);
                            for i in 0..list_ident.size {
                                val.as_mut_ptr().offset(i as isize).write({
                        let map_ident = __protocol.read_map_begin()?;
                        let mut val = ::std::collections::BTreeMap::new();
                        for _ in 0..map_ident.size {
                            val.insert(::pilota::thrift::Message::decode(__protocol)?, __protocol.read_faststr()?);
                        }
                        __protocol.read_map_end()?;
                        val
                    });
                            };
                            val.set_len(list_ident.size);
                            __protocol.read_list_end()?;
                            val
                        });
                    };
                    __protocol.read_set_end()?;
                    val});
                        }
                        __protocol.read_map_end()?;
                        val
                    });
                        }
                        __protocol.read_map_end()?;
                        val
                    });
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    Some(4)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_4 = Some(__protocol.read_bytes()?);
                                    }
                                    Some(5)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Uuid =>
                                    {
                                        var_5 = Some(__protocol.read_uuid()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `CrazyNesting` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_3) = var_3 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field list_field is required".to_string(),
                                ),
                            );
                        };

                        let data = Self {
                            string_field: var_1,
                            set_field: var_2,
                            list_field: var_3,
                            binary_field: var_4,
                            uuid_field: var_5,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;
                            let mut var_3 = None;
                            let mut var_4 = None;
                            let mut var_5 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Set  => {
                    var_2 = Some({let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(<Insanity as ::pilota::thrift::Message>::decode_async(__protocol).await?);
                    };
                    __protocol.read_set_end().await?;
                    val});

                },Some(3) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_3 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::std::collections::BTreeMap::new();
                        for _ in 0..map_ident.size {
                            val.insert({let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::std::collections::BTreeSet::new();
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_i32().await?);
                    };
                    __protocol.read_set_end().await?;
                    val}, {
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::std::collections::BTreeMap::new();
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i32().await?, {let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::std::collections::BTreeSet::new();
                    for _ in 0..list_ident.size {
                        val.insert({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::std::collections::BTreeMap::new();
                        for _ in 0..map_ident.size {
                            val.insert(<Insanity as ::pilota::thrift::Message>::decode_async(__protocol).await?, __protocol.read_faststr().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });
                    };
                    __protocol.read_set_end().await?;
                    val});
                        }
                        __protocol.read_map_end().await?;
                        val
                    });
                        }
                        __protocol.read_map_end().await?;
                        val
                    });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },Some(4) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_4 = Some(__protocol.read_bytes().await?);

                },Some(5) if field_ident.field_type == ::pilota::thrift::TType::Uuid  => {
                    var_5 = Some(__protocol.read_uuid().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `CrazyNesting` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_3) = var_3 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field list_field is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self {
                                string_field: var_1,
                                set_field: var_2,
                                list_field: var_3,
                                binary_field: var_4,
                                uuid_field: var_5,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                        name: "CrazyNesting",
                    }) + self.string_field.as_ref().map_or(0, |value| __protocol.faststr_field_len(Some(1), value)) +self.set_field.as_ref().map_or(0, |value| __protocol.set_field_len(Some(2), ::pilota::thrift::TType::Struct, value, |__protocol, el| {
                __protocol.struct_len(el)
            })) +__protocol.list_field_len(Some(3), ::pilota::thrift::TType::Map, &self.list_field, |__protocol, el| {
                        __protocol.btree_map_len(::pilota::thrift::TType::Set, ::pilota::thrift::TType::Map, el, |__protocol, key| {
                __protocol.btree_set_len(::pilota::thrift::TType::I32, key, |__protocol, el| {
                __protocol.i32_len(*el)
            })
            }, |__protocol, val| {
                __protocol.btree_map_len(::pilota::thrift::TType::I32, ::pilota::thrift::TType::Set, val, |__protocol, key| {
                __protocol.i32_len(*key)
            }, |__protocol, val| {
                __protocol.btree_set_len(::pilota::thrift::TType::List, val, |__protocol, el| {
                __protocol.list_len(::pilota::thrift::TType::Map, el, |__protocol, el| {
                        __protocol.btree_map_len(::pilota::thrift::TType::Struct, ::pilota::thrift::TType::Binary, el, |__protocol, key| {
                __protocol.struct_len(key)
            }, |__protocol, val| {
                __protocol.faststr_len(val)
            })
                    })
            })
            })
            })
                    }) +self.binary_field.as_ref().map_or(0, |value| __protocol.bytes_field_len(Some(4), value)) +self.uuid_field.as_ref().map_or(0, |value| __protocol.uuid_field_len(Some(5), *value) ) + __protocol.field_stop_len() + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
                 * @param binary  thing - the binary data to print
                 * @return binary  - returns the binary 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestBinaryResultSend {
                    fn default() -> Self {
                        ThriftTestTestBinaryResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestBinaryResultSend {
                    /**
                     * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
                     * @param binary  thing - the binary data to print
                     * @return binary  - returns the binary 'thing'
                     */
                    Ok(::pilota::Bytes),
                }

                impl ::pilota::thrift::Message for ThriftTestTestBinaryResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBinaryResultSend",
                        })?;
                        match self {
                            ThriftTestTestBinaryResultSend::Ok(value) => {
                                __protocol.write_bytes_field(0, (value).clone())?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_bytes()?;
                                        __protocol.bytes_len(&field_ident);
                                        ret = Some(ThriftTestTestBinaryResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_bytes().await?;

                                            ret = Some(ThriftTestTestBinaryResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBinaryResultSend",
                        }) + match self {
                            ThriftTestTestBinaryResultSend::Ok(value) => {
                                __protocol.bytes_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testString("%s")' with thing as '%s'
                 * @param string thing - the string to print
                 * @return string - returns the string 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct SecondServiceSecondtestStringArgsSend {
                    pub thing: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for SecondServiceSecondtestStringArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "SecondServiceSecondtestStringArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.thing).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `SecondServiceSecondtestStringArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `SecondServiceSecondtestStringArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "SecondServiceSecondtestStringArgsSend",
                        }) + __protocol.faststr_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testByte("%d")' with thing as '%d'
                 * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
                 * @param byte thing - the i8/byte to print
                 * @return i8 - returns the i8/byte 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestByteResultSend {
                    fn default() -> Self {
                        ThriftTestTestByteResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestByteResultSend {
                    /**
                     * Prints 'testByte("%d")' with thing as '%d'
                     * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
                     * @param byte thing - the i8/byte to print
                     * @return i8 - returns the i8/byte 'thing'
                     */
                    Ok(i8),
                }

                impl ::pilota::thrift::Message for ThriftTestTestByteResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestByteResultSend",
                        })?;
                        match self {
                            ThriftTestTestByteResultSend::Ok(value) => {
                                __protocol.write_i8_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_i8()?;
                                        __protocol.i8_len(*&field_ident);
                                        ret = Some(ThriftTestTestByteResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_i8().await?;

                                            ret =
                                                Some(ThriftTestTestByteResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestByteResultSend",
                        }) + match self {
                            ThriftTestTestByteResultSend::Ok(value) => {
                                __protocol.i8_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
                 * @param string arg - a string indicating what type of exception to throw
                 * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
                 * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
                 * else do not throw anything
                 * @return Xtruct - an Xtruct with string_thing = arg1
                 */

                impl ::std::default::Default for ThriftTestTestMultiExceptionResultRecv {
                    fn default() -> Self {
                        ThriftTestTestMultiExceptionResultRecv::Ok(
                            ::std::default::Default::default(),
                        )
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMultiExceptionResultRecv {
                    /**
                     * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
                     * @param string arg - a string indicating what type of exception to throw
                     * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
                     * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
                     * else do not throw anything
                     * @return Xtruct - an Xtruct with string_thing = arg1
                     */
                    Ok(Xtruct),

                    Err1(Xception),

                    Err2(Xception2),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMultiExceptionResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionResultRecv",
                        })?;
                        match self {
                            ThriftTestTestMultiExceptionResultRecv::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                            ThriftTestTestMultiExceptionResultRecv::Err1(value) => {
                                __protocol.write_struct_field(
                                    1,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                            ThriftTestTestMultiExceptionResultRecv::Err2(value) => {
                                __protocol.write_struct_field(
                                    2,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiExceptionResultRecv::Ok(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(1) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiExceptionResultRecv::Err1(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(2) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiExceptionResultRecv::Err2(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestMultiExceptionResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(1) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestMultiExceptionResultRecv::Err1(
                                                    field_ident,
                                                ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(2) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception2 as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestMultiExceptionResultRecv::Err2(
                                                    field_ident,
                                                ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionResultRecv",
                        }) + match self {
                            ThriftTestTestMultiExceptionResultRecv::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                            ThriftTestTestMultiExceptionResultRecv::Err1(value) => {
                                __protocol.struct_field_len(Some(1), value)
                            }
                            ThriftTestTestMultiExceptionResultRecv::Err2(value) => {
                                __protocol.struct_field_len(Some(2), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct Xception {
                    pub error_code: ::std::option::Option<i32>,

                    pub message: ::std::option::Option<::pilota::FastStr>,
                }
                impl ::pilota::thrift::Message for Xception {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "Xception" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.error_code.as_ref() {
                            __protocol.write_i32_field(1, *value)?;
                        }
                        if let Some(value) = self.message.as_ref() {
                            __protocol.write_faststr_field(2, (value).clone())?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_2 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `Xception` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            error_code: var_1,
                            message: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_2 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `Xception` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                error_code: var_1,
                                message: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "Xception",
                        }) + self
                            .error_code
                            .as_ref()
                            .map_or(0, |value| __protocol.i32_field_len(Some(1), *value))
                            + self
                                .message
                                .as_ref()
                                .map_or(0, |value| __protocol.faststr_field_len(Some(2), value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMapMap("%d")' with hello as '%d'
                 * @param i32 hello - the i32 to print
                 * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
                 *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestMapMapArgsSend {
                    pub hello: i32,
                }
                impl ::pilota::thrift::Message for ThriftTestTestMapMapArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapMapArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i32_field(1, *&self.hello)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestMapMapArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field hello is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { hello: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestMapMapArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field hello is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { hello: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapMapArgsSend",
                        }) + __protocol.i32_field_len(Some(1), *&self.hello)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct GuessProtocolStruct {
                    pub map_field: ::std::option::Option<
                        ::pilota::AHashMap<::pilota::FastStr, ::pilota::FastStr>,
                    >,
                }
                impl ::pilota::thrift::Message for GuessProtocolStruct {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "GuessProtocolStruct",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.map_field.as_ref() {
                            __protocol.write_map_field(
                                7,
                                ::pilota::thrift::TType::Binary,
                                ::pilota::thrift::TType::Binary,
                                &value,
                                |__protocol, key| {
                                    __protocol.write_faststr((key).clone())?;
                                    ::std::result::Result::Ok(())
                                },
                                |__protocol, val| {
                                    __protocol.write_faststr((val).clone())?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_7 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(7)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_7 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_faststr()?,
                                                    __protocol.read_faststr()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `GuessProtocolStruct` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self { map_field: var_7 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_7 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(7) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_7 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_faststr().await?, __protocol.read_faststr().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `GuessProtocolStruct` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self { map_field: var_7 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "GuessProtocolStruct",
                        }) + self.map_field.as_ref().map_or(0, |value| {
                            __protocol.map_field_len(
                                Some(7),
                                ::pilota::thrift::TType::Binary,
                                ::pilota::thrift::TType::Binary,
                                value,
                                |__protocol, key| __protocol.faststr_len(key),
                                |__protocol, val| __protocol.faststr_len(val),
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
                 *  separated by commas and new lines
                 * @param set<i32> thing - the set<i32> to print
                 * @return set<i32> - returns the set<i32> 'thing'
                 */
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestSetArgsSend {
                    pub thing: ::pilota::AHashSet<i32>,
                }
                impl ::pilota::thrift::Message for ThriftTestTestSetArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestSetArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_set_field(
                            1,
                            ::pilota::thrift::TType::I32,
                            &&self.thing,
                            |__protocol, val| {
                                __protocol.write_i32(*val)?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Set =>
                                    {
                                        var_1 = Some({
                                            let list_ident = __protocol.read_set_begin()?;
                                            let mut val =
                                                ::pilota::AHashSet::with_capacity(list_ident.size);
                                            for _ in 0..list_ident.size {
                                                val.insert(__protocol.read_i32()?);
                                            }
                                            __protocol.read_set_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestSetArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Set  => {
                    var_1 = Some({let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_i32().await?);
                    };
                    __protocol.read_set_end().await?;
                    val});

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestSetArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestSetArgsSend",
                        }) + __protocol.set_field_len(
                            Some(1),
                            ::pilota::thrift::TType::I32,
                            &self.thing,
                            |__protocol, el| __protocol.i32_len(*el),
                        ) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
                 * @param Xtruct thing - the Xtruct to print
                 * @return Xtruct - returns the Xtruct 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestStructArgsSend {
                    pub thing: Xtruct,
                }
                impl ::pilota::thrift::Message for ThriftTestTestStructArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStructArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_struct_field(
                            1,
                            &self.thing,
                            ::pilota::thrift::TType::Struct,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestStructArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestStructArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStructArgsSend",
                        }) + __protocol.struct_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * So you think you've got this all worked out, eh?
                 *
                 * Creates a map with these values and prints it out:
                 *   { 1 => { 2 => argument,
                 *            3 => argument,
                 *          },
                 *     2 => { 6 => <empty Insanity struct>, },
                 *   }
                 * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestInsanityArgsRecv {
                    pub argument: Insanity,
                }
                impl ::pilota::thrift::Message for ThriftTestTestInsanityArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestInsanityArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_struct_field(
                            1,
                            &self.argument,
                            ::pilota::thrift::TType::Struct,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestInsanityArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field argument is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { argument: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<Insanity as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestInsanityArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field argument is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { argument: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestInsanityArgsRecv",
                        }) + __protocol.struct_field_len(Some(1), &self.argument)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct NestedListsBonk {
                    pub bonk: ::std::option::Option<
                        ::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<Bonk>>>,
                    >,
                }
                impl ::pilota::thrift::Message for NestedListsBonk {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "NestedListsBonk",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.bonk.as_ref() {
                            __protocol.write_list_field(
                                1,
                                ::pilota::thrift::TType::List,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_list(
                                        ::pilota::thrift::TType::List,
                                        &val,
                                        |__protocol, val| {
                                            __protocol.write_list(
                                                ::pilota::thrift::TType::Struct,
                                                &val,
                                                |__protocol, val| {
                                                    __protocol.write_struct(val)?;
                                                    ::std::result::Result::Ok(())
                                                },
                                            )?;
                                            ::std::result::Result::Ok(())
                                        },
                                    )?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<
                                                ::std::vec::Vec<::std::vec::Vec<Bonk>>,
                                            > = ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write(unsafe {
                            let list_ident = __protocol.read_list_begin()?;
                            let mut val: ::std::vec::Vec<::std::vec::Vec<Bonk>> = ::std::vec::Vec::with_capacity(list_ident.size);
                            for i in 0..list_ident.size {
                                val.as_mut_ptr().offset(i as isize).write(unsafe {
                            let list_ident = __protocol.read_list_begin()?;
                            let mut val: ::std::vec::Vec<Bonk> = ::std::vec::Vec::with_capacity(list_ident.size);
                            for i in 0..list_ident.size {
                                val.as_mut_ptr().offset(i as isize).write(::pilota::thrift::Message::decode(__protocol)?);
                            };
                            val.set_len(list_ident.size);
                            __protocol.read_list_end()?;
                            val
                        });
                            };
                            val.set_len(list_ident.size);
                            __protocol.read_list_end()?;
                            val
                        });
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `NestedListsBonk` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self { bonk: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(<Bonk as ::pilota::thrift::Message>::decode_async(__protocol).await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `NestedListsBonk` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self { bonk: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "NestedListsBonk",
                        }) + self.bonk.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(1),
                                ::pilota::thrift::TType::List,
                                value,
                                |__protocol, el| {
                                    __protocol.list_len(
                                        ::pilota::thrift::TType::List,
                                        el,
                                        |__protocol, el| {
                                            __protocol.list_len(
                                                ::pilota::thrift::TType::Struct,
                                                el,
                                                |__protocol, el| __protocol.struct_len(el),
                                            )
                                        },
                                    )
                                },
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testI64("%d")' with thing as '%d'
                 * @param i64 thing - the i64 to print
                 * @return i64 - returns the i64 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestI64ArgsSend {
                    pub thing: i64,
                }
                impl ::pilota::thrift::Message for ThriftTestTestI64ArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI64ArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i64_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_1 = Some(__protocol.read_i64()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestI64ArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_1 = Some(__protocol.read_i64().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestI64ArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI64ArgsSend",
                        }) + __protocol.i64_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testList("{%s}")' where thing has been formatted into a string of values
                 *  separated by commas and new lines
                 * @param list<i32> thing - the list<i32> to print
                 * @return list<i32> - returns the list<i32> 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestListArgsRecv {
                    pub thing: ::std::vec::Vec<i32>,
                }
                impl ::pilota::thrift::Message for ThriftTestTestListArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestListArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_list_field(
                            1,
                            ::pilota::thrift::TType::I32,
                            &&self.thing,
                            |__protocol, val| {
                                __protocol.write_i32(*val)?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<i32> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr()
                                                    .offset(i as isize)
                                                    .write(__protocol.read_i32()?);
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestListArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_i32().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestListArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestListArgsRecv",
                        }) + __protocol.list_field_len(
                            Some(1),
                            ::pilota::thrift::TType::I32,
                            &self.thing,
                            |__protocol, el| __protocol.i32_len(*el),
                        ) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testString("%s")' with thing as '%s'
                 * @param string thing - the string to print
                 * @return string - returns the string 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestStringArgsSend {
                    pub thing: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for ThriftTestTestStringArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.thing).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestStringArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestStringArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringArgsSend",
                        }) + __protocol.faststr_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
                 * @param Xtruct2 thing - the Xtruct2 to print
                 * @return Xtruct2 - returns the Xtruct2 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestNestArgsRecv {
                    pub thing: Xtruct2,
                }
                impl ::pilota::thrift::Message for ThriftTestTestNestArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestNestArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_struct_field(
                            1,
                            &self.thing,
                            ::pilota::thrift::TType::Struct,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestNestArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_1 = Some(<Xtruct2 as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestNestArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestNestArgsRecv",
                        }) + __protocol.struct_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testException(%s)' with arg as '%s'
                 * @param string arg - a string indication what type of exception to throw
                 * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
                 * else if arg == "TException" throw TException
                 * else do not throw anything
                 */

                impl ::std::default::Default for ThriftTestTestExceptionResultRecv {
                    fn default() -> Self {
                        ThriftTestTestExceptionResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestExceptionResultRecv {
                    /**
                     * Print 'testException(%s)' with arg as '%s'
                     * @param string arg - a string indication what type of exception to throw
                     * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
                     * else if arg == "TException" throw TException
                     * else do not throw anything
                     */
                    Ok(()),

                    Err1(Xception),
                }

                impl ::pilota::thrift::Message for ThriftTestTestExceptionResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionResultRecv",
                        })?;
                        match self {
                            ThriftTestTestExceptionResultRecv::Ok(value) => {}
                            ThriftTestTestExceptionResultRecv::Err1(value) => {
                                __protocol.write_struct_field(
                                    1,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(1) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestExceptionResultRecv::Err1(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Ok(ThriftTestTestExceptionResultRecv::Ok(()))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(1) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestExceptionResultRecv::Err1(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Ok(ThriftTestTestExceptionResultRecv::Ok(()))
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestExceptionResultRecv",
                        }) + match self {
                            ThriftTestTestExceptionResultRecv::Ok(value) => 0,
                            ThriftTestTestExceptionResultRecv::Err1(value) => {
                                __protocol.struct_field_len(Some(1), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct Xtruct2 {
                    pub byte_thing: ::std::option::Option<i8>, // used to be byte, hence the name

                    pub struct_thing: ::std::option::Option<Xtruct>,

                    pub i32_thing: ::std::option::Option<i32>,
                }
                impl ::pilota::thrift::Message for Xtruct2 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier { name: "Xtruct2" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.byte_thing.as_ref() {
                            __protocol.write_i8_field(1, *value)?;
                        }
                        if let Some(value) = self.struct_thing.as_ref() {
                            __protocol.write_struct_field(
                                2,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        if let Some(value) = self.i32_thing.as_ref() {
                            __protocol.write_i32_field(3, *value)?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;
                        let mut var_3 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I8 =>
                                    {
                                        var_1 = Some(__protocol.read_i8()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_2 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(3)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_3 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `Xtruct2` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            byte_thing: var_1,
                            struct_thing: var_2,
                            i32_thing: var_3,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;
                            let mut var_3 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I8  => {
                    var_1 = Some(__protocol.read_i8().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_2 = Some(<Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(3) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_3 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `Xtruct2` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                byte_thing: var_1,
                                struct_thing: var_2,
                                i32_thing: var_3,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "Xtruct2",
                        }) + self
                            .byte_thing
                            .as_ref()
                            .map_or(0, |value| __protocol.i8_field_len(Some(1), *value))
                            + self
                                .struct_thing
                                .as_ref()
                                .map_or(0, |value| __protocol.struct_field_len(Some(2), value))
                            + self
                                .i32_thing
                                .as_ref()
                                .map_or(0, |value| __protocol.i32_field_len(Some(3), *value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testDouble("%f")' with thing as '%f'
                 * @param double thing - the double to print
                 * @return double - returns the double 'thing'
                 */
                #[derive(PartialOrd, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestDoubleArgsRecv {
                    pub thing: f64,
                }
                impl ::pilota::thrift::Message for ThriftTestTestDoubleArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestDoubleArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_double_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Double =>
                                    {
                                        var_1 = Some(__protocol.read_double()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestDoubleArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Double  => {
                    var_1 = Some(__protocol.read_double().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestDoubleArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestDoubleArgsRecv",
                        }) + __protocol.double_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testTypedef("%d")' with thing as '%d'
                 * @param UserId thing - the UserId to print
                 * @return UserId - returns the UserId 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestTypedefResultRecv {
                    fn default() -> Self {
                        ThriftTestTestTypedefResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestTypedefResultRecv {
                    /**
                     * Prints 'testTypedef("%d")' with thing as '%d'
                     * @param UserId thing - the UserId to print
                     * @return UserId - returns the UserId 'thing'
                     */
                    Ok(UserId),
                }

                impl ::pilota::thrift::Message for ThriftTestTestTypedefResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestTypedefResultRecv",
                        })?;
                        match self {
                            ThriftTestTestTypedefResultRecv::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::I64,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret =
                                            Some(ThriftTestTestTypedefResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestTypedefResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestTypedefResultRecv",
                        }) + match self {
                            ThriftTestTestTypedefResultRecv::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
                 * @param bool  thing - the bool data to print
                 * @return bool  - returns the bool 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestBoolArgsRecv {
                    pub thing: bool,
                }
                impl ::pilota::thrift::Message for ThriftTestTestBoolArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBoolArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_bool_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Bool =>
                                    {
                                        var_1 = Some(__protocol.read_bool()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestBoolArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Bool  => {
                    var_1 = Some(__protocol.read_bool().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestBoolArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBoolArgsRecv",
                        }) + __protocol.bool_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
                 *  separated by commas and new lines
                 * @param map<string,string> thing - the map<string,string> to print
                 * @return map<string,string> - returns the map<string,string> 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestStringMapResultRecv {
                    fn default() -> Self {
                        ThriftTestTestStringMapResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestStringMapResultRecv {
                    /**
                     * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
                     *  separated by commas and new lines
                     * @param map<string,string> thing - the map<string,string> to print
                     * @return map<string,string> - returns the map<string,string> 'thing'
                     */
                    Ok(::pilota::AHashMap<::pilota::FastStr, ::pilota::FastStr>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestStringMapResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringMapResultRecv",
                        })?;
                        match self {
                            ThriftTestTestStringMapResultRecv::Ok(value) => {
                                __protocol.write_map_field(
                                    0,
                                    ::pilota::thrift::TType::Binary,
                                    ::pilota::thrift::TType::Binary,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_faststr((key).clone())?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_faststr((val).clone())?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_faststr()?,
                                                    __protocol.read_faststr()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::Binary,
                                            ::pilota::thrift::TType::Binary,
                                            &field_ident,
                                            |__protocol, key| __protocol.faststr_len(key),
                                            |__protocol, val| __protocol.faststr_len(val),
                                        );
                                        ret = Some(ThriftTestTestStringMapResultRecv::Ok(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(
                                                        __protocol.read_faststr().await?,
                                                        __protocol.read_faststr().await?,
                                                    );
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret = Some(ThriftTestTestStringMapResultRecv::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringMapResultRecv",
                        }) + match self {
                            ThriftTestTestStringMapResultRecv::Ok(value) => __protocol
                                .map_field_len(
                                    Some(0),
                                    ::pilota::thrift::TType::Binary,
                                    ::pilota::thrift::TType::Binary,
                                    value,
                                    |__protocol, key| __protocol.faststr_len(key),
                                    |__protocol, val| __protocol.faststr_len(val),
                                ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testUuid("%s")' where '%s' is the uuid given. Note that the uuid byte order should be correct.
                 * @param uuid  thing - the uuid to print
                 * @return uuid  - returns the uuid 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestUuidResultRecv {
                    fn default() -> Self {
                        ThriftTestTestUuidResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestUuidResultRecv {
                    /**
                     * Prints 'testUuid("%s")' where '%s' is the uuid given. Note that the uuid byte order should be correct.
                     * @param uuid  thing - the uuid to print
                     * @return uuid  - returns the uuid 'thing'
                     */
                    Ok([u8; 16]),
                }

                impl ::pilota::thrift::Message for ThriftTestTestUuidResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestUuidResultRecv",
                        })?;
                        match self {
                            ThriftTestTestUuidResultRecv::Ok(value) => {
                                __protocol.write_uuid_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_uuid()?;
                                        __protocol.uuid_len(*&field_ident);
                                        ret = Some(ThriftTestTestUuidResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_uuid().await?;

                                            ret =
                                                Some(ThriftTestTestUuidResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestUuidResultRecv",
                        }) + match self {
                            ThriftTestTestUuidResultRecv::Ok(value) => {
                                __protocol.uuid_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct VersioningTestV2 {
                    pub begin_in_both: ::std::option::Option<i32>,

                    pub newint: ::std::option::Option<i32>,

                    pub newbyte: ::std::option::Option<i8>,

                    pub newshort: ::std::option::Option<i16>,

                    pub newlong: ::std::option::Option<i64>,

                    pub newdouble: ::std::option::Option<f64>,

                    pub newstruct: ::std::option::Option<Bonk>,

                    pub newlist: ::std::option::Option<::std::vec::Vec<i32>>,

                    pub newset: ::std::option::Option<::pilota::AHashSet<i32>>,

                    pub newmap: ::std::option::Option<::pilota::AHashMap<i32, i32>>,

                    pub newstring: ::std::option::Option<::pilota::FastStr>,

                    pub end_in_both: ::std::option::Option<i32>,
                }
                impl ::pilota::thrift::Message for VersioningTestV2 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "VersioningTestV2",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.begin_in_both.as_ref() {
                            __protocol.write_i32_field(1, *value)?;
                        }
                        if let Some(value) = self.newint.as_ref() {
                            __protocol.write_i32_field(2, *value)?;
                        }
                        if let Some(value) = self.newbyte.as_ref() {
                            __protocol.write_i8_field(3, *value)?;
                        }
                        if let Some(value) = self.newshort.as_ref() {
                            __protocol.write_i16_field(4, *value)?;
                        }
                        if let Some(value) = self.newlong.as_ref() {
                            __protocol.write_i64_field(5, *value)?;
                        }
                        if let Some(value) = self.newdouble.as_ref() {
                            __protocol.write_double_field(6, *value)?;
                        }
                        if let Some(value) = self.newstruct.as_ref() {
                            __protocol.write_struct_field(
                                7,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        if let Some(value) = self.newlist.as_ref() {
                            __protocol.write_list_field(
                                8,
                                ::pilota::thrift::TType::I32,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_i32(*val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.newset.as_ref() {
                            __protocol.write_set_field(
                                9,
                                ::pilota::thrift::TType::I32,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_i32(*val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.newmap.as_ref() {
                            __protocol.write_map_field(
                                10,
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::I32,
                                &value,
                                |__protocol, key| {
                                    __protocol.write_i32(*key)?;
                                    ::std::result::Result::Ok(())
                                },
                                |__protocol, val| {
                                    __protocol.write_i32(*val)?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        if let Some(value) = self.newstring.as_ref() {
                            __protocol.write_faststr_field(11, (value).clone())?;
                        }
                        if let Some(value) = self.end_in_both.as_ref() {
                            __protocol.write_i32_field(12, *value)?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;
                        let mut var_3 = None;
                        let mut var_4 = None;
                        let mut var_5 = None;
                        let mut var_6 = None;
                        let mut var_7 = None;
                        let mut var_8 = None;
                        let mut var_9 = None;
                        let mut var_10 = None;
                        let mut var_11 = None;
                        let mut var_12 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_2 = Some(__protocol.read_i32()?);
                                    }
                                    Some(3)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I8 =>
                                    {
                                        var_3 = Some(__protocol.read_i8()?);
                                    }
                                    Some(4)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I16 =>
                                    {
                                        var_4 = Some(__protocol.read_i16()?);
                                    }
                                    Some(5)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_5 = Some(__protocol.read_i64()?);
                                    }
                                    Some(6)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Double =>
                                    {
                                        var_6 = Some(__protocol.read_double()?);
                                    }
                                    Some(7)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_7 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    Some(8)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_8 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<i32> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr()
                                                    .offset(i as isize)
                                                    .write(__protocol.read_i32()?);
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    Some(9)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Set =>
                                    {
                                        var_9 = Some({
                                            let list_ident = __protocol.read_set_begin()?;
                                            let mut val =
                                                ::pilota::AHashSet::with_capacity(list_ident.size);
                                            for _ in 0..list_ident.size {
                                                val.insert(__protocol.read_i32()?);
                                            }
                                            __protocol.read_set_end()?;
                                            val
                                        });
                                    }
                                    Some(10)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_10 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_i32()?,
                                                    __protocol.read_i32()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    Some(11)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_11 = Some(__protocol.read_faststr()?);
                                    }
                                    Some(12)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_12 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `VersioningTestV2` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            begin_in_both: var_1,
                            newint: var_2,
                            newbyte: var_3,
                            newshort: var_4,
                            newlong: var_5,
                            newdouble: var_6,
                            newstruct: var_7,
                            newlist: var_8,
                            newset: var_9,
                            newmap: var_10,
                            newstring: var_11,
                            end_in_both: var_12,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;
                            let mut var_3 = None;
                            let mut var_4 = None;
                            let mut var_5 = None;
                            let mut var_6 = None;
                            let mut var_7 = None;
                            let mut var_8 = None;
                            let mut var_9 = None;
                            let mut var_10 = None;
                            let mut var_11 = None;
                            let mut var_12 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_2 = Some(__protocol.read_i32().await?);

                },Some(3) if field_ident.field_type == ::pilota::thrift::TType::I8  => {
                    var_3 = Some(__protocol.read_i8().await?);

                },Some(4) if field_ident.field_type == ::pilota::thrift::TType::I16  => {
                    var_4 = Some(__protocol.read_i16().await?);

                },Some(5) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_5 = Some(__protocol.read_i64().await?);

                },Some(6) if field_ident.field_type == ::pilota::thrift::TType::Double  => {
                    var_6 = Some(__protocol.read_double().await?);

                },Some(7) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_7 = Some(<Bonk as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },Some(8) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_8 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_i32().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },Some(9) if field_ident.field_type == ::pilota::thrift::TType::Set  => {
                    var_9 = Some({let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_i32().await?);
                    };
                    __protocol.read_set_end().await?;
                    val});

                },Some(10) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_10 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_i32().await?, __protocol.read_i32().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },Some(11) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_11 = Some(__protocol.read_faststr().await?);

                },Some(12) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_12 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `VersioningTestV2` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                begin_in_both: var_1,
                                newint: var_2,
                                newbyte: var_3,
                                newshort: var_4,
                                newlong: var_5,
                                newdouble: var_6,
                                newstruct: var_7,
                                newlist: var_8,
                                newset: var_9,
                                newmap: var_10,
                                newstring: var_11,
                                end_in_both: var_12,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "VersioningTestV2",
                        }) + self
                            .begin_in_both
                            .as_ref()
                            .map_or(0, |value| __protocol.i32_field_len(Some(1), *value))
                            + self
                                .newint
                                .as_ref()
                                .map_or(0, |value| __protocol.i32_field_len(Some(2), *value))
                            + self
                                .newbyte
                                .as_ref()
                                .map_or(0, |value| __protocol.i8_field_len(Some(3), *value))
                            + self
                                .newshort
                                .as_ref()
                                .map_or(0, |value| __protocol.i16_field_len(Some(4), *value))
                            + self
                                .newlong
                                .as_ref()
                                .map_or(0, |value| __protocol.i64_field_len(Some(5), *value))
                            + self
                                .newdouble
                                .as_ref()
                                .map_or(0, |value| __protocol.double_field_len(Some(6), *value))
                            + self
                                .newstruct
                                .as_ref()
                                .map_or(0, |value| __protocol.struct_field_len(Some(7), value))
                            + self.newlist.as_ref().map_or(0, |value| {
                                __protocol.list_field_len(
                                    Some(8),
                                    ::pilota::thrift::TType::I32,
                                    value,
                                    |__protocol, el| __protocol.i32_len(*el),
                                )
                            })
                            + self.newset.as_ref().map_or(0, |value| {
                                __protocol.set_field_len(
                                    Some(9),
                                    ::pilota::thrift::TType::I32,
                                    value,
                                    |__protocol, el| __protocol.i32_len(*el),
                                )
                            })
                            + self.newmap.as_ref().map_or(0, |value| {
                                __protocol.map_field_len(
                                    Some(10),
                                    ::pilota::thrift::TType::I32,
                                    ::pilota::thrift::TType::I32,
                                    value,
                                    |__protocol, key| __protocol.i32_len(*key),
                                    |__protocol, val| __protocol.i32_len(*val),
                                )
                            })
                            + self
                                .newstring
                                .as_ref()
                                .map_or(0, |value| __protocol.faststr_field_len(Some(11), value))
                            + self
                                .end_in_both
                                .as_ref()
                                .map_or(0, |value| __protocol.i32_field_len(Some(12), *value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testI32("%d")' with thing as '%d'
                 * @param i32 thing - the i32 to print
                 * @return i32 - returns the i32 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestI32ResultRecv {
                    fn default() -> Self {
                        ThriftTestTestI32ResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestI32ResultRecv {
                    /**
                     * Prints 'testI32("%d")' with thing as '%d'
                     * @param i32 thing - the i32 to print
                     * @return i32 - returns the i32 'thing'
                     */
                    Ok(i32),
                }

                impl ::pilota::thrift::Message for ThriftTestTestI32ResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI32ResultRecv",
                        })?;
                        match self {
                            ThriftTestTestI32ResultRecv::Ok(value) => {
                                __protocol.write_i32_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_i32()?;
                                        __protocol.i32_len(*&field_ident);
                                        ret = Some(ThriftTestTestI32ResultRecv::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_i32().await?;

                                            ret =
                                                Some(ThriftTestTestI32ResultRecv::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestI32ResultRecv",
                        }) + match self {
                            ThriftTestTestI32ResultRecv::Ok(value) => {
                                __protocol.i32_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
                 * @param string arg - a string indicating what type of exception to throw
                 * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
                 * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
                 * else do not throw anything
                 * @return Xtruct - an Xtruct with string_thing = arg1
                 */

                impl ::std::default::Default for ThriftTestTestMultiExceptionResultSend {
                    fn default() -> Self {
                        ThriftTestTestMultiExceptionResultSend::Ok(
                            ::std::default::Default::default(),
                        )
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestMultiExceptionResultSend {
                    /**
                     * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
                     * @param string arg - a string indicating what type of exception to throw
                     * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
                     * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
                     * else do not throw anything
                     * @return Xtruct - an Xtruct with string_thing = arg1
                     */
                    Ok(Xtruct),

                    Err1(Xception),

                    Err2(Xception2),
                }

                impl ::pilota::thrift::Message for ThriftTestTestMultiExceptionResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionResultSend",
                        })?;
                        match self {
                            ThriftTestTestMultiExceptionResultSend::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                            ThriftTestTestMultiExceptionResultSend::Err1(value) => {
                                __protocol.write_struct_field(
                                    1,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                            ThriftTestTestMultiExceptionResultSend::Err2(value) => {
                                __protocol.write_struct_field(
                                    2,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiExceptionResultSend::Ok(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(1) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiExceptionResultSend::Err1(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(2) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestMultiExceptionResultSend::Err2(
                                            field_ident,
                                        ));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(ThriftTestTestMultiExceptionResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(1) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestMultiExceptionResultSend::Err1(
                                                    field_ident,
                                                ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(2) => {
                                        if ret.is_none() {
                                            let field_ident = <Xception2 as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestMultiExceptionResultSend::Err2(
                                                    field_ident,
                                                ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionResultSend",
                        }) + match self {
                            ThriftTestTestMultiExceptionResultSend::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                            ThriftTestTestMultiExceptionResultSend::Err1(value) => {
                                __protocol.struct_field_len(Some(1), value)
                            }
                            ThriftTestTestMultiExceptionResultSend::Err2(value) => {
                                __protocol.struct_field_len(Some(2), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints "testVoid()" and returns nothing.
                 */

                impl ::std::default::Default for ThriftTestTestVoidResultRecv {
                    fn default() -> Self {
                        ThriftTestTestVoidResultRecv::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestVoidResultRecv {
                    /**
                     * Prints "testVoid()" and returns nothing.
                     */
                    Ok(()),
                }

                impl ::pilota::thrift::Message for ThriftTestTestVoidResultRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestVoidResultRecv",
                        })?;
                        match self {
                            ThriftTestTestVoidResultRecv::Ok(value) => {}
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Ok(ThriftTestTestVoidResultRecv::Ok(()))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Ok(ThriftTestTestVoidResultRecv::Ok(()))
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestVoidResultRecv",
                        }) + match self {
                            ThriftTestTestVoidResultRecv::Ok(value) => 0,
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * So you think you've got this all worked out, eh?
                 *
                 * Creates a map with these values and prints it out:
                 *   { 1 => { 2 => argument,
                 *            3 => argument,
                 *          },
                 *     2 => { 6 => <empty Insanity struct>, },
                 *   }
                 * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
                 */

                impl ::std::default::Default for ThriftTestTestInsanityResultSend {
                    fn default() -> Self {
                        ThriftTestTestInsanityResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum ThriftTestTestInsanityResultSend {
                    /**
                     * So you think you've got this all worked out, eh?
                     *
                     * Creates a map with these values and prints it out:
                     *   { 1 => { 2 => argument,
                     *            3 => argument,
                     *          },
                     *     2 => { 6 => <empty Insanity struct>, },
                     *   }
                     * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
                     */
                    Ok(::pilota::AHashMap<UserId, ::pilota::AHashMap<Numberz, Insanity>>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestInsanityResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestInsanityResultSend",
                        })?;
                        match self {
                            ThriftTestTestInsanityResultSend::Ok(value) => {
                                __protocol.write_map_field(
                                    0,
                                    ::pilota::thrift::TType::I64,
                                    ::pilota::thrift::TType::Map,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_struct(key)?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_map(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::Struct,
                                            &val,
                                            |__protocol, key| {
                                                __protocol.write_struct(key)?;
                                                ::std::result::Result::Ok(())
                                            },
                                            |__protocol, val| {
                                                __protocol.write_struct(val)?;
                                                ::std::result::Result::Ok(())
                                            },
                                        )?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    ::pilota::thrift::Message::decode(__protocol)?,
                                                    {
                                                        let map_ident =
                                                            __protocol.read_map_begin()?;
                                                        let mut val =
                                                            ::pilota::AHashMap::with_capacity(
                                                                map_ident.size,
                                                            );
                                                        for _ in 0..map_ident.size {
                                                            val.insert(
                                                                ::pilota::thrift::Message::decode(
                                                                    __protocol,
                                                                )?,
                                                                ::pilota::thrift::Message::decode(
                                                                    __protocol,
                                                                )?,
                                                            );
                                                        }
                                                        __protocol.read_map_end()?;
                                                        val
                                                    },
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I64,
                                            ::pilota::thrift::TType::Map,
                                            &field_ident,
                                            |__protocol, key| __protocol.struct_len(key),
                                            |__protocol, val| {
                                                __protocol.map_len(
                                                    ::pilota::thrift::TType::I32,
                                                    ::pilota::thrift::TType::Struct,
                                                    val,
                                                    |__protocol, key| __protocol.struct_len(key),
                                                    |__protocol, val| __protocol.struct_len(val),
                                                )
                                            },
                                        );
                                        ret =
                                            Some(ThriftTestTestInsanityResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(<UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?, {
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(<Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?, <Insanity as ::pilota::thrift::Message>::decode_async(__protocol).await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret = Some(ThriftTestTestInsanityResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestInsanityResultSend",
                        }) + match self {
                            ThriftTestTestInsanityResultSend::Ok(value) => __protocol
                                .map_field_len(
                                    Some(0),
                                    ::pilota::thrift::TType::I64,
                                    ::pilota::thrift::TType::Map,
                                    value,
                                    |__protocol, key| __protocol.struct_len(key),
                                    |__protocol, val| {
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::Struct,
                                            val,
                                            |__protocol, key| __protocol.struct_len(key),
                                            |__protocol, val| __protocol.struct_len(val),
                                        )
                                    },
                                ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }

                #[derive(PartialOrd, Debug, Default, Clone, PartialEq)]
                pub struct NestedListsDoublex2 {
                    pub doublelist: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<f64>>>,
                }
                impl ::pilota::thrift::Message for NestedListsDoublex2 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "NestedListsDoublex2",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.doublelist.as_ref() {
                            __protocol.write_list_field(
                                1,
                                ::pilota::thrift::TType::List,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_list(
                                        ::pilota::thrift::TType::Double,
                                        &val,
                                        |__protocol, val| {
                                            __protocol.write_double(*val)?;
                                            ::std::result::Result::Ok(())
                                        },
                                    )?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::List =>
                                    {
                                        var_1 = Some(unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<::std::vec::Vec<f64>> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr().offset(i as isize).write(unsafe {
                                                    let list_ident =
                                                        __protocol.read_list_begin()?;
                                                    let mut val: ::std::vec::Vec<f64> =
                                                        ::std::vec::Vec::with_capacity(
                                                            list_ident.size,
                                                        );
                                                    for i in 0..list_ident.size {
                                                        val.as_mut_ptr()
                                                            .offset(i as isize)
                                                            .write(__protocol.read_double()?);
                                                    }
                                                    val.set_len(list_ident.size);
                                                    __protocol.read_list_end()?;
                                                    val
                                                });
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `NestedListsDoublex2` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self { doublelist: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::List  => {
                    var_1 = Some({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push({
                            let list_ident = __protocol.read_list_begin().await?;
                            let mut val = ::std::vec::Vec::with_capacity(list_ident.size);
                            for _ in 0..list_ident.size {
                                val.push(__protocol.read_double().await?);
                            };
                            __protocol.read_list_end().await?;
                            val
                        });
                            };
                            __protocol.read_list_end().await?;
                            val
                        });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `NestedListsDoublex2` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self { doublelist: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "NestedListsDoublex2",
                        }) + self.doublelist.as_ref().map_or(0, |value| {
                            __protocol.list_field_len(
                                Some(1),
                                ::pilota::thrift::TType::List,
                                value,
                                |__protocol, el| {
                                    __protocol.list_len(
                                        ::pilota::thrift::TType::Double,
                                        el,
                                        |__protocol, el| __protocol.double_len(*el),
                                    )
                                },
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testList("{%s}")' where thing has been formatted into a string of values
                 *  separated by commas and new lines
                 * @param list<i32> thing - the list<i32> to print
                 * @return list<i32> - returns the list<i32> 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestListResultSend {
                    fn default() -> Self {
                        ThriftTestTestListResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestListResultSend {
                    /**
                     * Prints 'testList("{%s}")' where thing has been formatted into a string of values
                     *  separated by commas and new lines
                     * @param list<i32> thing - the list<i32> to print
                     * @return list<i32> - returns the list<i32> 'thing'
                     */
                    Ok(::std::vec::Vec<i32>),
                }

                impl ::pilota::thrift::Message for ThriftTestTestListResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestListResultSend",
                        })?;
                        match self {
                            ThriftTestTestListResultSend::Ok(value) => {
                                __protocol.write_list_field(
                                    0,
                                    ::pilota::thrift::TType::I32,
                                    &value,
                                    |__protocol, val| {
                                        __protocol.write_i32(*val)?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = unsafe {
                                            let list_ident = __protocol.read_list_begin()?;
                                            let mut val: ::std::vec::Vec<i32> =
                                                ::std::vec::Vec::with_capacity(list_ident.size);
                                            for i in 0..list_ident.size {
                                                val.as_mut_ptr()
                                                    .offset(i as isize)
                                                    .write(__protocol.read_i32()?);
                                            }
                                            val.set_len(list_ident.size);
                                            __protocol.read_list_end()?;
                                            val
                                        };
                                        __protocol.list_len(
                                            ::pilota::thrift::TType::I32,
                                            &field_ident,
                                            |__protocol, el| __protocol.i32_len(*el),
                                        );
                                        ret = Some(ThriftTestTestListResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let list_ident =
                                                    __protocol.read_list_begin().await?;
                                                let mut val =
                                                    ::std::vec::Vec::with_capacity(list_ident.size);
                                                for _ in 0..list_ident.size {
                                                    val.push(__protocol.read_i32().await?);
                                                }
                                                __protocol.read_list_end().await?;
                                                val
                                            };

                                            ret =
                                                Some(ThriftTestTestListResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestListResultSend",
                        }) + match self {
                            ThriftTestTestListResultSend::Ok(value) => __protocol.list_field_len(
                                Some(0),
                                ::pilota::thrift::TType::I32,
                                value,
                                |__protocol, el| __protocol.i32_len(*el),
                            ),
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
                 * @param string arg - a string indicating what type of exception to throw
                 * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
                 * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
                 * else do not throw anything
                 * @return Xtruct - an Xtruct with string_thing = arg1
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestMultiExceptionArgsSend {
                    pub arg0: ::pilota::FastStr,

                    pub arg1: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for ThriftTestTestMultiExceptionArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.arg0).clone())?;
                        __protocol.write_faststr_field(2, (&self.arg1).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_2 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestMultiExceptionArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg0 is required".to_string(),
                                ),
                            );
                        };
                        let Some(var_2) = var_2 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field arg1 is required".to_string(),
                                ),
                            );
                        };

                        let data = Self {
                            arg0: var_1,
                            arg1: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_2 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestMultiExceptionArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg0 is required".to_string(),
                                    ),
                                );
                            };
                            let Some(var_2) = var_2 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field arg1 is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self {
                                arg0: var_1,
                                arg1: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMultiExceptionArgsSend",
                        }) + __protocol.faststr_field_len(Some(1), &self.arg0)
                            + __protocol.faststr_field_len(Some(2), &self.arg1)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
                 * @param Xtruct2 thing - the Xtruct2 to print
                 * @return Xtruct2 - returns the Xtruct2 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestNestResultSend {
                    fn default() -> Self {
                        ThriftTestTestNestResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestNestResultSend {
                    /**
                     * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
                     * @param Xtruct2 thing - the Xtruct2 to print
                     * @return Xtruct2 - returns the Xtruct2 'thing'
                     */
                    Ok(Xtruct2),
                }

                impl ::pilota::thrift::Message for ThriftTestTestNestResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestNestResultSend",
                        })?;
                        match self {
                            ThriftTestTestNestResultSend::Ok(value) => {
                                __protocol.write_struct_field(
                                    0,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(ThriftTestTestNestResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct2 as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret =
                                                Some(ThriftTestTestNestResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestNestResultSend",
                        }) + match self {
                            ThriftTestTestNestResultSend::Ok(value) => {
                                __protocol.struct_field_len(Some(0), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct MapType(pub ::pilota::AHashMap<::pilota::FastStr, Bonk>);

                impl ::std::ops::Deref for MapType {
                    type Target = ::pilota::AHashMap<::pilota::FastStr, Bonk>;

                    fn deref(&self) -> &Self::Target {
                        &self.0
                    }
                }

                impl From<::pilota::AHashMap<::pilota::FastStr, Bonk>> for MapType {
                    fn from(v: ::pilota::AHashMap<::pilota::FastStr, Bonk>) -> Self {
                        Self(v)
                    }
                }

                impl ::pilota::thrift::Message for MapType {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_map(
                            ::pilota::thrift::TType::Binary,
                            ::pilota::thrift::TType::Struct,
                            &(&**self),
                            |__protocol, key| {
                                __protocol.write_faststr((key).clone())?;
                                ::std::result::Result::Ok(())
                            },
                            |__protocol, val| {
                                __protocol.write_struct(val)?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        ::std::result::Result::Ok(MapType({
                            let map_ident = __protocol.read_map_begin()?;
                            let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                            for _ in 0..map_ident.size {
                                val.insert(
                                    __protocol.read_faststr()?,
                                    ::pilota::thrift::Message::decode(__protocol)?,
                                );
                            }
                            __protocol.read_map_end()?;
                            val
                        }))
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            ::std::result::Result::Ok(MapType({
                                let map_ident = __protocol.read_map_begin().await?;
                                let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                                for _ in 0..map_ident.size {
                                    val.insert(
                                        __protocol.read_faststr().await?,
                                        <Bonk as ::pilota::thrift::Message>::decode_async(
                                            __protocol,
                                        )
                                        .await?,
                                    );
                                }
                                __protocol.read_map_end().await?;
                                val
                            }))
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.map_len(
                            ::pilota::thrift::TType::Binary,
                            ::pilota::thrift::TType::Struct,
                            &**self,
                            |__protocol, key| __protocol.faststr_len(key),
                            |__protocol, val| __protocol.struct_len(val),
                        )
                    }
                }

                impl ::std::default::Default for OptionalSetDefaultTest {
                    fn default() -> Self {
                        OptionalSetDefaultTest {
                            with_default: Some(::pilota::AHashSet::from([
                                ::pilota::FastStr::from_static_str("test"),
                            ])),
                        }
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub struct OptionalSetDefaultTest {
                    pub with_default: ::std::option::Option<::pilota::AHashSet<::pilota::FastStr>>,
                }
                impl ::pilota::thrift::Message for OptionalSetDefaultTest {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "OptionalSetDefaultTest",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.with_default.as_ref() {
                            __protocol.write_set_field(
                                1,
                                ::pilota::thrift::TType::Binary,
                                &value,
                                |__protocol, val| {
                                    __protocol.write_faststr((val).clone())?;
                                    ::std::result::Result::Ok(())
                                },
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Set =>
                                    {
                                        var_1 = Some({
                                            let list_ident = __protocol.read_set_begin()?;
                                            let mut val =
                                                ::pilota::AHashSet::with_capacity(list_ident.size);
                                            for _ in 0..list_ident.size {
                                                val.insert(__protocol.read_faststr()?);
                                            }
                                            __protocol.read_set_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `OptionalSetDefaultTest` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        if var_1.is_none() {
                            var_1 = Some(::pilota::AHashSet::from([
                                ::pilota::FastStr::from_static_str("test"),
                            ]));
                        }

                        let data = Self {
                            with_default: var_1,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Set  => {
                    var_1 = Some({let list_ident = __protocol.read_set_begin().await?;
                    let mut val = ::pilota::AHashSet::with_capacity(list_ident.size);
                    for _ in 0..list_ident.size {
                        val.insert(__protocol.read_faststr().await?);
                    };
                    __protocol.read_set_end().await?;
                    val});

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `OptionalSetDefaultTest` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            if var_1.is_none() {
                                var_1 = Some(::pilota::AHashSet::from([
                                    ::pilota::FastStr::from_static_str("test"),
                                ]));
                            }

                            let data = Self {
                                with_default: var_1,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "OptionalSetDefaultTest",
                        }) + self.with_default.as_ref().map_or(0, |value| {
                            __protocol.set_field_len(
                                Some(1),
                                ::pilota::thrift::TType::Binary,
                                value,
                                |__protocol, el| __protocol.faststr_len(el),
                            )
                        }) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testDouble("%f")' with thing as '%f'
                 * @param double thing - the double to print
                 * @return double - returns the double 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestDoubleResultSend {
                    fn default() -> Self {
                        ThriftTestTestDoubleResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestDoubleResultSend {
                    /**
                     * Prints 'testDouble("%f")' with thing as '%f'
                     * @param double thing - the double to print
                     * @return double - returns the double 'thing'
                     */
                    Ok(f64),
                }

                impl ::pilota::thrift::Message for ThriftTestTestDoubleResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestDoubleResultSend",
                        })?;
                        match self {
                            ThriftTestTestDoubleResultSend::Ok(value) => {
                                __protocol.write_double_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_double()?;
                                        __protocol.double_len(*&field_ident);
                                        ret = Some(ThriftTestTestDoubleResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_double().await?;

                                            ret = Some(ThriftTestTestDoubleResultSend::Ok(
                                                field_ident,
                                            ));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestDoubleResultSend",
                        }) + match self {
                            ThriftTestTestDoubleResultSend::Ok(value) => {
                                __protocol.double_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
                 * sleep 'secondsToSleep'
                 * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
                 * @param i32 secondsToSleep - the number of seconds to sleep
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestOnewayArgsRecv {
                    pub seconds_to_sleep: i32,
                }
                impl ::pilota::thrift::Message for ThriftTestTestOnewayArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestOnewayArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i32_field(1, *&self.seconds_to_sleep)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestOnewayArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field seconds_to_sleep is required".to_string(),
                                ),
                            );
                        };

                        let data = Self {
                            seconds_to_sleep: var_1,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestOnewayArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field seconds_to_sleep is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self {
                                seconds_to_sleep: var_1,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestOnewayArgsRecv",
                        }) + __protocol.i32_field_len(Some(1), *&self.seconds_to_sleep)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
                 * @param bool  thing - the bool data to print
                 * @return bool  - returns the bool 'thing'
                 */

                impl ::std::default::Default for ThriftTestTestBoolResultSend {
                    fn default() -> Self {
                        ThriftTestTestBoolResultSend::Ok(::std::default::Default::default())
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Clone, PartialEq)]
                pub enum ThriftTestTestBoolResultSend {
                    /**
                     * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
                     * @param bool  thing - the bool data to print
                     * @return bool  - returns the bool 'thing'
                     */
                    Ok(bool),
                }

                impl ::pilota::thrift::Message for ThriftTestTestBoolResultSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBoolResultSend",
                        })?;
                        match self {
                            ThriftTestTestBoolResultSend::Ok(value) => {
                                __protocol.write_bool_field(0, *value)?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(0) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_bool()?;
                                        __protocol.bool_len(*&field_ident);
                                        ret = Some(ThriftTestTestBoolResultSend::Ok(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(0) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_bool().await?;

                                            ret =
                                                Some(ThriftTestTestBoolResultSend::Ok(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestBoolResultSend",
                        }) + match self {
                            ThriftTestTestBoolResultSend::Ok(value) => {
                                __protocol.bool_field_len(Some(0), *value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                impl ::std::default::Default for SomeUnion {
                    fn default() -> Self {
                        SomeUnion::MapThing(::std::default::Default::default())
                    }
                }
                #[derive(Debug, Clone, PartialEq)]
                pub enum SomeUnion {
                    MapThing(::pilota::AHashMap<Numberz, UserId>),

                    StringThing(::pilota::FastStr),

                    I32Thing(i32),

                    XtructThing(Xtruct3),

                    InsanityThing(Insanity),
                }

                impl ::pilota::thrift::Message for SomeUnion {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        __protocol.write_struct_begin(&::pilota::thrift::TStructIdentifier {
                            name: "SomeUnion",
                        })?;
                        match self {
                            SomeUnion::MapThing(value) => {
                                __protocol.write_map_field(
                                    1,
                                    ::pilota::thrift::TType::I32,
                                    ::pilota::thrift::TType::I64,
                                    &value,
                                    |__protocol, key| {
                                        __protocol.write_struct(key)?;
                                        ::std::result::Result::Ok(())
                                    },
                                    |__protocol, val| {
                                        __protocol.write_struct(val)?;
                                        ::std::result::Result::Ok(())
                                    },
                                )?;
                            }
                            SomeUnion::StringThing(value) => {
                                __protocol.write_faststr_field(2, (value).clone())?;
                            }
                            SomeUnion::I32Thing(value) => {
                                __protocol.write_i32_field(3, *value)?;
                            }
                            SomeUnion::XtructThing(value) => {
                                __protocol.write_struct_field(
                                    4,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                            SomeUnion::InsanityThing(value) => {
                                __protocol.write_struct_field(
                                    5,
                                    value,
                                    ::pilota::thrift::TType::Struct,
                                )?;
                            }
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};
                        let mut ret = None;
                        __protocol.read_struct_begin()?;
                        loop {
                            let field_ident = __protocol.read_field_begin()?;
                            if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                __protocol.field_stop_len();
                                break;
                            } else {
                                __protocol.field_begin_len(field_ident.field_type, field_ident.id);
                            }
                            match field_ident.id {
                                Some(1) => {
                                    if ret.is_none() {
                                        let field_ident = {
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    ::pilota::thrift::Message::decode(__protocol)?,
                                                    ::pilota::thrift::Message::decode(__protocol)?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        };
                                        __protocol.map_len(
                                            ::pilota::thrift::TType::I32,
                                            ::pilota::thrift::TType::I64,
                                            &field_ident,
                                            |__protocol, key| __protocol.struct_len(key),
                                            |__protocol, val| __protocol.struct_len(val),
                                        );
                                        ret = Some(SomeUnion::MapThing(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(2) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_faststr()?;
                                        __protocol.faststr_len(&field_ident);
                                        ret = Some(SomeUnion::StringThing(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(3) => {
                                    if ret.is_none() {
                                        let field_ident = __protocol.read_i32()?;
                                        __protocol.i32_len(*&field_ident);
                                        ret = Some(SomeUnion::I32Thing(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(4) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(SomeUnion::XtructThing(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                Some(5) => {
                                    if ret.is_none() {
                                        let field_ident =
                                            ::pilota::thrift::Message::decode(__protocol)?;
                                        __protocol.struct_len(&field_ident);
                                        ret = Some(SomeUnion::InsanityThing(field_ident));
                                    } else {
                                        return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                    }
                                }
                                _ => {
                                    __protocol.skip(field_ident.field_type)?;
                                }
                            }
                        }
                        __protocol.read_field_end()?;
                        __protocol.read_struct_end()?;
                        if let Some(ret) = ret {
                            ::std::result::Result::Ok(ret)
                        } else {
                            ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                "received empty union from remote Message",
                            ))
                        }
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut ret = None;
                            __protocol.read_struct_begin().await?;
                            loop {
                                let field_ident = __protocol.read_field_begin().await?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    break;
                                } else {
                                }
                                match field_ident.id {
                                    Some(1) => {
                                        if ret.is_none() {
                                            let field_ident = {
                                                let map_ident = __protocol.read_map_begin().await?;
                                                let mut val = ::pilota::AHashMap::with_capacity(
                                                    map_ident.size,
                                                );
                                                for _ in 0..map_ident.size {
                                                    val.insert(<Numberz as ::pilota::thrift::Message>::decode_async(__protocol).await?, <UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?);
                                                }
                                                __protocol.read_map_end().await?;
                                                val
                                            };

                                            ret = Some(SomeUnion::MapThing(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(2) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_faststr().await?;

                                            ret = Some(SomeUnion::StringThing(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(3) => {
                                        if ret.is_none() {
                                            let field_ident = __protocol.read_i32().await?;

                                            ret = Some(SomeUnion::I32Thing(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(4) => {
                                        if ret.is_none() {
                                            let field_ident = <Xtruct3 as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(SomeUnion::XtructThing(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    Some(5) => {
                                        if ret.is_none() {
                                            let field_ident = <Insanity as ::pilota::thrift::Message>::decode_async(__protocol).await?;

                                            ret = Some(SomeUnion::InsanityThing(field_ident));
                                        } else {
                                            return ::std::result::Result::Err(::pilota::thrift::new_protocol_exception(
                                            ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                            "received multiple fields for union from remote Message"
                                        ));
                                        }
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type).await?;
                                    }
                                }
                            }
                            __protocol.read_field_end().await?;
                            __protocol.read_struct_end().await?;
                            if let Some(ret) = ret {
                                ::std::result::Result::Ok(ret)
                            } else {
                                ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "received empty union from remote Message",
                                    ),
                                )
                            }
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "SomeUnion",
                        }) + match self {
                            SomeUnion::MapThing(value) => __protocol.map_field_len(
                                Some(1),
                                ::pilota::thrift::TType::I32,
                                ::pilota::thrift::TType::I64,
                                value,
                                |__protocol, key| __protocol.struct_len(key),
                                |__protocol, val| __protocol.struct_len(val),
                            ),
                            SomeUnion::StringThing(value) => {
                                __protocol.faststr_field_len(Some(2), value)
                            }
                            SomeUnion::I32Thing(value) => __protocol.i32_field_len(Some(3), *value),
                            SomeUnion::XtructThing(value) => {
                                __protocol.struct_field_len(Some(4), value)
                            }
                            SomeUnion::InsanityThing(value) => {
                                __protocol.struct_field_len(Some(5), value)
                            }
                        } + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testTypedef("%d")' with thing as '%d'
                 * @param UserId thing - the UserId to print
                 * @return UserId - returns the UserId 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestTypedefArgsSend {
                    pub thing: UserId,
                }
                impl ::pilota::thrift::Message for ThriftTestTestTypedefArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestTypedefArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_struct_field(
                            1,
                            &self.thing,
                            ::pilota::thrift::TType::I64,
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I64 =>
                                    {
                                        var_1 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestTypedefArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I64  => {
                    var_1 = Some(<UserId as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestTypedefArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestTypedefArgsSend",
                        }) + __protocol.struct_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testString("%s")' with thing as '%s'
                 * @param string thing - the string to print
                 * @return string - returns the string 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct SecondServiceSecondtestStringArgsRecv {
                    pub thing: ::pilota::FastStr,
                }
                impl ::pilota::thrift::Message for SecondServiceSecondtestStringArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "SecondServiceSecondtestStringArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_faststr_field(1, (&self.thing).clone())?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Binary =>
                                    {
                                        var_1 = Some(__protocol.read_faststr()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `SecondServiceSecondtestStringArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Binary  => {
                    var_1 = Some(__protocol.read_faststr().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `SecondServiceSecondtestStringArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "SecondServiceSecondtestStringArgsRecv",
                        }) + __protocol.faststr_field_len(Some(1), &self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
                 *  separated by commas and new lines
                 * @param map<string,string> thing - the map<string,string> to print
                 * @return map<string,string> - returns the map<string,string> 'thing'
                 */
                #[derive(Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestStringMapArgsSend {
                    pub thing: ::pilota::AHashMap<::pilota::FastStr, ::pilota::FastStr>,
                }
                impl ::pilota::thrift::Message for ThriftTestTestStringMapArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringMapArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_map_field(
                            1,
                            ::pilota::thrift::TType::Binary,
                            ::pilota::thrift::TType::Binary,
                            &&self.thing,
                            |__protocol, key| {
                                __protocol.write_faststr((key).clone())?;
                                ::std::result::Result::Ok(())
                            },
                            |__protocol, val| {
                                __protocol.write_faststr((val).clone())?;
                                ::std::result::Result::Ok(())
                            },
                        )?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Map =>
                                    {
                                        var_1 = Some({
                                            let map_ident = __protocol.read_map_begin()?;
                                            let mut val =
                                                ::pilota::AHashMap::with_capacity(map_ident.size);
                                            for _ in 0..map_ident.size {
                                                val.insert(
                                                    __protocol.read_faststr()?,
                                                    __protocol.read_faststr()?,
                                                );
                                            }
                                            __protocol.read_map_end()?;
                                            val
                                        });
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestStringMapArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Map  => {
                    var_1 = Some({
                        let map_ident = __protocol.read_map_begin().await?;
                        let mut val = ::pilota::AHashMap::with_capacity(map_ident.size);
                        for _ in 0..map_ident.size {
                            val.insert(__protocol.read_faststr().await?, __protocol.read_faststr().await?);
                        }
                        __protocol.read_map_end().await?;
                        val
                    });

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestStringMapArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestStringMapArgsSend",
                        }) + __protocol.map_field_len(
                            Some(1),
                            ::pilota::thrift::TType::Binary,
                            ::pilota::thrift::TType::Binary,
                            &self.thing,
                            |__protocol, key| __protocol.faststr_len(key),
                            |__protocol, val| __protocol.faststr_len(val),
                        ) + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct Xception2 {
                    pub error_code: ::std::option::Option<i32>,

                    pub struct_thing: ::std::option::Option<Xtruct>,
                }
                impl ::pilota::thrift::Message for Xception2 {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident =
                            ::pilota::thrift::TStructIdentifier { name: "Xception2" };

                        __protocol.write_struct_begin(&struct_ident)?;
                        if let Some(value) = self.error_code.as_ref() {
                            __protocol.write_i32_field(1, *value)?;
                        }
                        if let Some(value) = self.struct_thing.as_ref() {
                            __protocol.write_struct_field(
                                2,
                                value,
                                ::pilota::thrift::TType::Struct,
                            )?;
                        }
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;
                        let mut var_2 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    Some(2)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Struct =>
                                    {
                                        var_2 =
                                            Some(::pilota::thrift::Message::decode(__protocol)?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!(
                                    "decode struct `Xception2` field(#{}) failed, caused by: ",
                                    field_id
                                ));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let data = Self {
                            error_code: var_1,
                            struct_thing: var_2,
                        };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;
                            let mut var_2 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },Some(2) if field_ident.field_type == ::pilota::thrift::TType::Struct  => {
                    var_2 = Some(<Xtruct as ::pilota::thrift::Message>::decode_async(__protocol).await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `Xception2` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let data = Self {
                                error_code: var_1,
                                struct_thing: var_2,
                            };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "Xception2",
                        }) + self
                            .error_code
                            .as_ref()
                            .map_or(0, |value| __protocol.i32_field_len(Some(1), *value))
                            + self
                                .struct_thing
                                .as_ref()
                                .map_or(0, |value| __protocol.struct_field_len(Some(2), value))
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testUuid("%s")' where '%s' is the uuid given. Note that the uuid byte order should be correct.
                 * @param uuid  thing - the uuid to print
                 * @return uuid  - returns the uuid 'thing'
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestUuidArgsSend {
                    pub thing: [u8; 16],
                }
                impl ::pilota::thrift::Message for ThriftTestTestUuidArgsSend {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestUuidArgsSend",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_uuid_field(1, *&self.thing)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::Uuid =>
                                    {
                                        var_1 = Some(__protocol.read_uuid()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestUuidArgsSend` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field thing is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { thing: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::Uuid  => {
                    var_1 = Some(__protocol.read_uuid().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestUuidArgsSend` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field thing is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { thing: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestUuidArgsSend",
                        }) + __protocol.uuid_field_len(Some(1), *&self.thing)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
                /**
                 * Prints 'testMapMap("%d")' with hello as '%d'
                 * @param i32 hello - the i32 to print
                 * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
                 *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
                 */
                #[derive(PartialOrd, Hash, Eq, Ord, Debug, Default, Clone, PartialEq)]
                pub struct ThriftTestTestMapMapArgsRecv {
                    pub hello: i32,
                }
                impl ::pilota::thrift::Message for ThriftTestTestMapMapArgsRecv {
                    fn encode<T: ::pilota::thrift::TOutputProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> ::std::result::Result<(), ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TOutputProtocolExt;
                        let struct_ident = ::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapMapArgsRecv",
                        };

                        __protocol.write_struct_begin(&struct_ident)?;
                        __protocol.write_i32_field(1, *&self.hello)?;
                        __protocol.write_field_stop()?;
                        __protocol.write_struct_end()?;
                        ::std::result::Result::Ok(())
                    }

                    fn decode<T: ::pilota::thrift::TInputProtocol>(
                        __protocol: &mut T,
                    ) -> ::std::result::Result<Self, ::pilota::thrift::ThriftException>
                    {
                        #[allow(unused_imports)]
                        use ::pilota::{Buf, thrift::TLengthProtocolExt};

                        let mut var_1 = None;

                        let mut __pilota_decoding_field_id = None;

                        __protocol.read_struct_begin()?;
                        if let ::std::result::Result::Err(mut err) = (|| {
                            loop {
                                let field_ident = __protocol.read_field_begin()?;
                                if field_ident.field_type == ::pilota::thrift::TType::Stop {
                                    __protocol.field_stop_len();
                                    break;
                                } else {
                                    __protocol
                                        .field_begin_len(field_ident.field_type, field_ident.id);
                                }
                                __pilota_decoding_field_id = field_ident.id;
                                match field_ident.id {
                                    Some(1)
                                        if field_ident.field_type
                                            == ::pilota::thrift::TType::I32 =>
                                    {
                                        var_1 = Some(__protocol.read_i32()?);
                                    }
                                    _ => {
                                        __protocol.skip(field_ident.field_type)?;
                                    }
                                }

                                __protocol.read_field_end()?;
                                __protocol.field_end_len();
                            }
                            ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                        })() {
                            if let Some(field_id) = __pilota_decoding_field_id {
                                err.prepend_msg(&format!("decode struct `ThriftTestTestMapMapArgsRecv` field(#{}) failed, caused by: ", field_id));
                            }
                            return ::std::result::Result::Err(err);
                        };
                        __protocol.read_struct_end()?;

                        let Some(var_1) = var_1 else {
                            return ::std::result::Result::Err(
                                ::pilota::thrift::new_protocol_exception(
                                    ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                    "field hello is required".to_string(),
                                ),
                            );
                        };

                        let data = Self { hello: var_1 };
                        ::std::result::Result::Ok(data)
                    }

                    fn decode_async<'a, T: ::pilota::thrift::TAsyncInputProtocol>(
                        __protocol: &'a mut T,
                    ) -> ::std::pin::Pin<
                        ::std::boxed::Box<
                            dyn ::std::future::Future<
                                    Output = ::std::result::Result<
                                        Self,
                                        ::pilota::thrift::ThriftException,
                                    >,
                                > + Send
                                + 'a,
                        >,
                    > {
                        ::std::boxed::Box::pin(async move {
                            let mut var_1 = None;

                            let mut __pilota_decoding_field_id = None;

                            __protocol.read_struct_begin().await?;
                            if let ::std::result::Result::Err(mut err) = async {
                    loop {


                let field_ident = __protocol.read_field_begin().await?;
                if field_ident.field_type == ::pilota::thrift::TType::Stop {

                    break;
                } else {

                }
                __pilota_decoding_field_id = field_ident.id;
                match field_ident.id {
                    Some(1) if field_ident.field_type == ::pilota::thrift::TType::I32  => {
                    var_1 = Some(__protocol.read_i32().await?);

                },
                    _ => {
                        __protocol.skip(field_ident.field_type).await?;

                    },
                }

                __protocol.read_field_end().await?;


            };
                    ::std::result::Result::Ok::<_, ::pilota::thrift::ThriftException>(())
                }.await {
                if let Some(field_id) = __pilota_decoding_field_id {
                    err.prepend_msg(&format!("decode struct `ThriftTestTestMapMapArgsRecv` field(#{}) failed, caused by: ", field_id));
                }
                return ::std::result::Result::Err(err);
            };
                            __protocol.read_struct_end().await?;

                            let Some(var_1) = var_1 else {
                                return ::std::result::Result::Err(
                                    ::pilota::thrift::new_protocol_exception(
                                        ::pilota::thrift::ProtocolExceptionKind::InvalidData,
                                        "field hello is required".to_string(),
                                    ),
                                );
                            };

                            let data = Self { hello: var_1 };
                            ::std::result::Result::Ok(data)
                        })
                    }

                    fn size<T: ::pilota::thrift::TLengthProtocol>(
                        &self,
                        __protocol: &mut T,
                    ) -> usize {
                        #[allow(unused_imports)]
                        use ::pilota::thrift::TLengthProtocolExt;
                        __protocol.struct_begin_len(&::pilota::thrift::TStructIdentifier {
                            name: "ThriftTestTestMapMapArgsRecv",
                        }) + __protocol.i32_field_len(Some(1), *&self.hello)
                            + __protocol.field_stop_len()
                            + __protocol.struct_end_len()
                    }
                }
            }
        }
    }
}
